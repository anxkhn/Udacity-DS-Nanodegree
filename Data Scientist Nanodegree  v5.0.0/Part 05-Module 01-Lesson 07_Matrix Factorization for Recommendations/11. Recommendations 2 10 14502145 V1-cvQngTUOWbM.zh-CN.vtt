WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:04.799
假设我们只有 2 个潜在特征

00:00:04.799 --> 00:00:07.619
其他不变

00:00:07.620 --> 00:00:11.685
我们希望代码更加灵活

00:00:11.685 --> 00:00:14.165
对于原始 U 矩阵

00:00:14.164 --> 00:00:15.754
我们依然想要保留所有行

00:00:15.755 --> 00:00:20.089
列数有 k 个然后

00:00:20.089 --> 00:00:25.559
为了使操作比之前更容易重现

00:00:25.559 --> 00:00:28.679
我们先创建这个矩阵

00:00:28.679 --> 00:00:29.960
即 k x k 矩阵然后

00:00:29.960 --> 00:00:33.329
我们将获取分量本身

00:00:33.329 --> 00:00:40.239
并放入 k 个对角线元素

00:00:51.530 --> 00:00:55.375
这部分代码的作用是提取前 2 个元素

00:00:55.375 --> 00:00:57.810
如果将这个改成 4

00:00:57.810 --> 00:00:59.804
则与我们之前看到的完全一样

00:00:59.804 --> 00:01:01.155
如果改成 3

00:01:01.155 --> 00:01:03.579
则提取前 3 个元素

00:01:09.590 --> 00:01:13.395
Ok应该没什么问题

00:01:13.394 --> 00:01:15.189
接下来

00:01:15.189 --> 00:01:18.694
我们将获得一个子集

00:01:18.694 --> 00:01:24.449
行数为潜在特征的数量 列数为所有电影数量

00:01:24.450 --> 00:01:29.120
这些形状看起来满足预期

00:01:29.120 --> 00:01:32.170
最后 我们需要计算

00:01:32.170 --> 00:01:35.659
每个矩阵之间的点积

00:01:35.659 --> 00:01:43.394
我们将计算 U 和 S 的点积 潜在特征是 2 个

00:01:43.394 --> 00:01:45.369
然后计算这个矩阵

00:01:45.370 --> 00:01:54.469
与 vt_2 的点积

00:01:54.469 --> 00:01:57.209
这样就能获得预期的评分

00:01:58.010 --> 00:02:01.660
我将这行代码复制到这里

00:02:01.819 --> 00:02:04.879
如果使用所有 4 个潜在特征

00:02:04.879 --> 00:02:07.179
则获得矩阵本身

00:02:07.180 --> 00:02:09.710
即原始矩阵

00:02:09.819 --> 00:02:12.995
而这是预测结果

00:02:12.995 --> 00:02:17.599
我们可以比较预测值与实际值之间的差异

00:02:17.599 --> 00:02:20.370
获取 user_movie_subset...

00:02:22.900 --> 00:02:26.015
我将快速注释掉这一行

00:02:26.014 --> 00:02:27.384
如果计算差异的话

00:02:27.384 --> 00:02:29.989
这是包含所有差异的数组

00:02:29.990 --> 00:02:33.740
要查看所有差异偏离了多少

00:02:33.740 --> 00:02:37.020
我们需要计算平方差

00:02:37.020 --> 00:02:39.000
然后相加

00:02:39.000 --> 00:02:41.520
一个 sum()

00:02:41.520 --> 00:02:46.150
将计算列上的和

00:02:46.150 --> 00:02:50.069
另一个 sum() 将计算行上的和

00:02:50.069 --> 00:02:52.769
好的

00:02:52.770 --> 00:02:56.880
将这部分放到这里

00:02:56.879 --> 00:02:58.000
希望你听明白了

00:02:58.000 --> 00:03:00.710
我们计算的是实际数据集与子集的差异

00:03:00.710 --> 00:03:02.730
如果计算平方差

00:03:02.729 --> 00:03:04.030
那么都是正数

00:03:04.030 --> 00:03:05.689
然后求和

00:03:05.689 --> 00:03:09.349
这样我们就能判断使用 2 个潜在特征

00:03:09.349 --> 00:03:13.259
计算原始矩阵与使用 4 个潜在特征相比效果如何

00:03:13.259 --> 00:03:14.794
将这些改成 new 

00:03:14.794 --> 00:03:25.810
然后求和

00:03:26.030 --> 00:03:30.210
结果是 6.49 e -28

00:03:30.210 --> 00:03:34.580
本质上是 0 可能是因为四舍五入导致的错误

00:03:34.879 --> 00:03:40.594
6 前面有 27 个 0 然后是小数点

00:03:40.594 --> 00:03:43.689
Ok我将这些再改回来

00:03:43.689 --> 00:03:50.754
希望能通过测试看起来没问题

00:03:50.754 --> 00:03:53.299
接下来 我们将尝试

00:03:53.300 --> 00:04:01.640
在添加一个 NaN 的情况下计算奇异值分解结果

00:04:01.639 --> 00:04:07.838
复制下之前在上面

00:04:07.838 --> 00:04:10.715
计算奇异值分解时用到的这行代码

00:04:10.715 --> 00:04:14.990
然后再回到这里

00:04:14.990 --> 00:04:17.485
运行这个单元格

00:04:17.485 --> 00:04:19.639
你会发现 我们遇到了一个错误

00:04:19.639 --> 00:04:21.810
错误消息是“svd did not converge.”

00:04:21.810 --> 00:04:23.360
主要原因是

00:04:23.360 --> 00:04:24.830
有一个 NaN 值

00:04:24.829 --> 00:04:27.259
接下来我们将学习一个策略

00:04:27.259 --> 00:04:31.680
当有些单元格没有值时可以采用该策略

