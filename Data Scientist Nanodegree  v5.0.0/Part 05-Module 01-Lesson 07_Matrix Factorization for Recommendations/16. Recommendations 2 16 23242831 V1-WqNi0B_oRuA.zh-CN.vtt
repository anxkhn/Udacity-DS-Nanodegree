WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:06.740
接下来 我们将使用前 1000 个用户

00:00:06.740 --> 00:00:10.605
将对这 1000 个用户应用 FunkSVD

00:00:10.605 --> 00:00:14.245
提取前 1,000 个用户

00:00:14.244 --> 00:00:19.809
迭代 20 次 需要一段运行时间

00:00:19.809 --> 00:00:22.479
迭代 20 次

00:00:22.480 --> 00:00:25.129
我们提取了 1000 个用户

00:00:25.129 --> 00:00:27.964
当然也可以使用整个 DataFrame

00:00:27.964 --> 00:00:29.339
这就要看你的机器计算能力

00:00:29.339 --> 00:00:34.804
以及你能接受多长的运行时间了

00:00:34.804 --> 00:00:37.399
这里出现了一些结果

00:00:37.399 --> 00:00:40.469
这些值符合我们的预期

00:00:40.469 --> 00:00:46.629
第一个均方误差为 23

00:00:46.630 --> 00:00:48.500
然后是 7 点多的值我们看看到第 20 次迭代时

00:00:48.500 --> 00:00:50.829
结果将是多少

00:00:50.829 --> 00:00:54.234
希望你的结果也符合预期

00:00:54.234 --> 00:00:56.975
我的结果都出来了

00:00:56.975 --> 00:01:00.649
误差越来越小

00:01:00.649 --> 00:01:04.429
我们可以继续运行 直到这些值更低

00:01:04.430 --> 00:01:07.640
可以看出 值依然以合理的规律下降

00:01:07.640 --> 00:01:12.210
但是我们直接从已经发生的情况中推断吧

00:01:12.209 --> 00:01:15.754
首先应该看看这前 1000 个用户

00:01:15.754 --> 00:01:20.989
看看该矩阵中缺少多少个值

00:01:20.989 --> 00:01:24.534
如果你没有自己查看表格标题的话

00:01:24.534 --> 00:01:29.840
提醒下 我使用的是之前的非零计数代码

00:01:29.840 --> 00:01:35.525
前 1,000 个用户中实际有多少个评分？有这么多

00:01:35.525 --> 00:01:37.910
我们对多少个实际上没有评分的

00:01:37.909 --> 00:01:40.310
用户-电影对预测了评分？

00:01:40.310 --> 00:01:45.025
计算方法是 shape.()

00:01:45.025 --> 00:01:48.310
和之前一样

00:01:48.310 --> 00:01:51.560
用行数乘以列数

00:01:51.560 --> 00:01:56.490
再减去 num_ratings

00:01:56.489 --> 00:02:01.069
这部分表示我们可能会获得的评分数量

00:02:01.069 --> 00:02:04.369
这部分表示 DataFrame 中的

00:02:04.370 --> 00:02:07.630
实际评分数量运行下代码

00:02:07.629 --> 00:02:12.049
可以看出 我们缺少了很多值

00:02:12.050 --> 00:02:17.240
只有大约 11,000 个评分 所以这个矩阵很稀疏

00:02:17.240 --> 00:02:22.855
我们来看看前 1,000 个用户

00:02:22.854 --> 00:02:25.879
基本上都是 NaN

00:02:25.879 --> 00:02:30.409
我们来看看行数和列数

00:02:30.409 --> 00:02:36.189
它有 1,000 个用户和 31,000 部电影

00:02:36.189 --> 00:02:41.650
缺少了大量值 只有大约 10,000 个评分

00:02:41.650 --> 00:02:43.730
运行时间比较久

00:02:43.729 --> 00:02:46.399
因为我们需要查看矩阵中的每个元素

00:02:46.400 --> 00:02:48.650
最后检查一下

00:02:48.650 --> 00:02:50.650
看来我的结果没问题

00:02:50.650 --> 00:02:55.189
这一步很重要 因为我们不需要内置函数

00:02:55.189 --> 00:02:58.234
可以自己构建一个函数

00:02:58.235 --> 00:03:02.665
现在能够传入无论多稀疏的矩阵

00:03:02.664 --> 00:03:07.519
并且能够计算本身不存在的用户-电影对评分

00:03:07.520 --> 00:03:12.005
我们能够确保学习方向是对的 并且将获得评分

00:03:12.004 --> 00:03:16.069
通过计算这两项的点积

00:03:16.069 --> 00:03:20.254
我们现在能够获得任何用户-电影的预测值

00:03:20.254 --> 00:03:22.590
如果获取某个用户的索引

00:03:22.590 --> 00:03:26.000
以及某部电影的索引

00:03:26.000 --> 00:03:28.909
然后计算这两项的点积

00:03:28.909 --> 00:03:33.215
我们将能预测该用户-电影评分 即使用户从未实际与该电影互动过

00:03:33.215 --> 00:03:37.080
这项功能太强大了 并且执行效果很好

