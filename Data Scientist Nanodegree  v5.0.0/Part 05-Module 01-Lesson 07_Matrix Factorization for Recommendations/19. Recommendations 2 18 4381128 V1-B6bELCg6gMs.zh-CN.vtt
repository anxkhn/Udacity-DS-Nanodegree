WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:04.065
下个单元格中的函数

00:00:04.065 --> 00:00:08.089
与在 FunkSVD 函数的解中创建的函数一样

00:00:08.089 --> 00:00:10.244
可以看到模型正在学习

00:00:10.244 --> 00:00:13.824
每次迭代之后 均方误差都越来越小

00:00:13.824 --> 00:00:19.960
我们将迭代 250 次 需要运行一段时间

00:00:19.960 --> 00:00:23.530
为了理解电影 我们使用了 15 个潜在特征

00:00:23.530 --> 00:00:27.089
这个值比较随意

00:00:27.089 --> 00:00:32.019
主要通过试错法确定这个数值

00:00:35.420 --> 00:00:40.115
让代码继续运行下去 运行时间较长

00:00:40.115 --> 00:00:44.810
现在你已经有一个用户矩阵和电影矩阵

00:00:44.810 --> 00:00:48.890
可以使用用户矩阵的行与电影矩阵的列

00:00:48.890 --> 00:00:53.674
之间的点积得出任何用户-电影预测值

00:00:53.674 --> 00:00:58.219
接下来我们就这么预测

00:00:58.219 --> 00:01:00.019
我们将传入用户矩阵和电影矩阵

00:01:00.020 --> 00:01:03.350
以及用户 ID 和电影 ID

00:01:03.350 --> 00:01:07.250
我们将根据这两个矩阵

00:01:07.250 --> 00:01:11.810
预测用户对该电影的评分

00:01:11.810 --> 00:01:17.030
首先 我们需要找到用户和电影矩阵中的索引

00:01:17.030 --> 00:01:22.820
并获得特定的用户 ID 或电影 ID

00:01:22.819 --> 00:01:25.639
如果你还记得之前的步骤的话

00:01:25.640 --> 00:01:27.394
我将代码放在这里

00:01:27.394 --> 00:01:30.810
我们可以使用 np.where 语句

00:01:30.810 --> 00:01:35.445
我们可以看看这个用户 ID 所在的位置

00:01:35.444 --> 00:01:37.569
看看传入的值是否等于该 user_id

00:01:37.569 --> 00:01:39.244
即 == user_id

00:01:39.245 --> 00:01:43.540
如果等于该 user_id 我们将提取该值

00:01:43.540 --> 00:01:45.945
之前使用 np.where 语句的时候

00:01:45.944 --> 00:01:49.159
它返回了这个嵌套结果

00:01:49.159 --> 00:01:52.905
我们将从中获取特定的数字

00:01:52.905 --> 00:01:56.739
为了查看这串索引是什么

00:01:56.739 --> 00:02:02.129
我们来看看训练 dataframe

00:02:02.129 --> 00:02:04.369
这是我们要根据它

00:02:04.370 --> 00:02:08.379
做出预测的电影矩阵

00:02:08.379 --> 00:02:10.180
即我们要查看的矩阵

00:02:10.180 --> 00:02:12.439
其中有很多零值

00:02:12.439 --> 00:02:19.129
这是用户 ID 数组

00:02:19.129 --> 00:02:23.659
这是电影 ID 数组

00:02:23.659 --> 00:02:28.585
我们将通过它们得出从用户电影矩阵中提取值的行和列索引

00:02:28.585 --> 00:02:32.045
下面说说我的提取方式

00:02:32.044 --> 00:02:35.659
如果对它调用 index

00:02:35.659 --> 00:02:38.344
返回的是用户

00:02:38.344 --> 00:02:41.039
如果调用 columns

00:02:41.789 --> 00:02:44.829
返回的是电影

00:02:44.830 --> 00:02:47.055
这些是电影 这些是列

00:02:47.055 --> 00:02:50.680
我只是将它们变成了 NumPy 数组

00:02:50.680 --> 00:02:56.585
我创建了这两个 NumPy 数组

00:02:56.585 --> 00:03:05.375
称之为 user_ids_series 和 movie_ids_series 并设为 NumPy 数组

00:03:05.375 --> 00:03:08.959
获取这个索引数组

00:03:08.959 --> 00:03:14.219
然后是 movie_ids_series

00:03:17.050 --> 00:03:22.280
Ok现在获得了这些可以使用的电影索引和用户索引

00:03:22.280 --> 00:03:26.955
我希望通过索引找到特定的电影或用户 ID

00:03:26.955 --> 00:03:28.665
也就是说

00:03:28.664 --> 00:03:30.674
如果这个值等于这个值

00:03:30.675 --> 00:03:35.640
则提取该索引 因为它是我要从 U 矩阵中获取的行

00:03:35.639 --> 00:03:39.439
所以我想要的用户行等于这个

00:03:39.439 --> 00:03:43.609
并且我想要的电影列等于这个

00:03:43.610 --> 00:03:46.325
两个基本一样

00:03:46.324 --> 00:03:51.409
但是来自 movie_ids_series 并且等于 movie_id

00:03:51.409 --> 00:03:55.759
然后传入索引 就像之前那样

00:03:55.759 --> 00:03:57.870
它会返回嵌套结果

00:03:57.870 --> 00:04:03.170
预测等于这两项的点积

00:04:03.169 --> 00:04:11.779
对于用户矩阵来说 行等于这个 user_row

00:04:11.780 --> 00:04:15.530
列是用户对应的所有列

00:04:15.530 --> 00:04:18.725
即这部分与

00:04:18.725 --> 00:04:24.550
传入的电影矩阵的点积

00:04:24.550 --> 00:04:26.540
电影矩阵正好相反

00:04:26.540 --> 00:04:31.140
我们想要所有行和 movie_col

00:04:31.139 --> 00:04:34.964
这样就获得了预测值

00:04:34.964 --> 00:04:37.979
对于这个用户-电影对

00:04:37.980 --> 00:04:41.865
即用户 8 对电影 2844 的评分

00:04:41.865 --> 00:04:45.670
预测结果是 6.65

