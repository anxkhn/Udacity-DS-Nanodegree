WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.955
我们将对这个评分矩阵

00:00:02.955 --> 00:00:08.879
应用 Funk SVD

00:00:08.880 --> 00:00:10.540
行表示用户 列表示电影

00:00:10.539 --> 00:00:13.379
单元格里的值表示

00:00:13.380 --> 00:00:16.710
特定用户-电影组合的评分

00:00:16.710 --> 00:00:18.725
首先 函数是这样的

00:00:18.725 --> 00:00:21.115
参数包括 ratings_mat

00:00:21.114 --> 00:00:23.559
即暂时这一部分

00:00:23.559 --> 00:00:26.154
还包括潜在特征的数量

00:00:26.155 --> 00:00:28.080
学习速率

00:00:28.079 --> 00:00:31.469
以及迭代次数

00:00:31.469 --> 00:00:35.759
用户数量等于行数

00:00:35.759 --> 00:00:41.574
电影数量等于这个

00:00:41.575 --> 00:00:46.984
评分数量等于这两个的乘积

00:00:46.984 --> 00:00:48.835
我们本可以这么计算

00:00:48.835 --> 00:00:51.535
但是 如果缺少值的话

00:00:51.534 --> 00:00:52.869
这么计算就不可行

00:00:52.869 --> 00:00:54.729
我将使用这部分代码

00:00:54.729 --> 00:00:58.369
这个函数将查看非零数字并计数

00:00:58.369 --> 00:01:03.609
这个 np.isnan 将遍历矩阵

00:01:03.609 --> 00:01:07.549
并记录是否缺少值

00:01:07.549 --> 00:01:13.200
我们将创建一个用随机值填充的矩阵

00:01:13.200 --> 00:01:15.144
在之前的视频中

00:01:15.144 --> 00:01:18.314
我们有两个矩阵 一个是用户矩阵

00:01:18.314 --> 00:01:21.769
它的行数是用户数量

00:01:21.769 --> 00:01:24.200
列数等于潜在特征的数量

00:01:24.200 --> 00:01:25.340
另一个是电影矩阵

00:01:25.340 --> 00:01:27.965
行数等于潜在特征的数量

00:01:27.965 --> 00:01:31.715
列数等于电影数量

00:01:31.715 --> 00:01:36.620
用户矩阵与电影矩阵的点积

00:01:36.620 --> 00:01:42.090
将等于原始的用户-电影矩阵

00:01:42.569 --> 00:01:46.029
for iteration in range(iters)

00:01:46.030 --> 00:01:48.879
iters 是在这里传入的值

00:01:48.879 --> 00:01:51.289
表示我们将遍历矩阵对

00:01:51.290 --> 00:01:55.630
并更新值多少次

00:01:55.629 --> 00:02:02.089
在视频中看到的不是一次完整的迭代

00:02:02.090 --> 00:02:04.340
一次完整的迭代

00:02:04.340 --> 00:02:07.799
需要遍历每个值一次

00:02:07.799 --> 00:02:09.090
现在

00:02:09.090 --> 00:02:11.500
我们将迭代 100 次

00:02:11.500 --> 00:02:13.520
对于每个用户-电影对

00:02:13.520 --> 00:02:16.275
对于每个用户

00:02:16.275 --> 00:02:21.140
for i in range(n_users)

00:02:22.289 --> 00:02:24.609
然后对于每部电影

00:02:24.610 --> 00:02:29.060
for j in range(n_movies)

00:02:29.060 --> 00:02:31.490
对于每个用户-电影对

00:02:31.490 --> 00:02:33.895
如果有评分

00:02:33.895 --> 00:02:38.530
如果矩阵中有评分

00:02:40.039 --> 00:02:45.364
即不为空

00:02:45.365 --> 00:02:49.240
我们的评分范围是 1-10

00:02:49.240 --> 00:02:53.710
所以如果评分大于 0

00:02:53.710 --> 00:02:58.790
如果 np.nan 大于 1 或大于 0

00:02:58.789 --> 00:03:00.739
结果为 false

00:03:00.740 --> 00:03:03.740
对我们来说是肯定的结果

00:03:03.740 --> 00:03:06.950
如果是 NaN 我们希望结果为 false

00:03:06.949 --> 00:03:10.619
如果存在一个值 则为 true

00:03:10.620 --> 00:03:15.069
接下来是视频中演示的实际迭代过程

00:03:15.069 --> 00:03:18.139
我们将计算

00:03:18.139 --> 00:03:22.159
实际值与

00:03:22.159 --> 00:03:25.085
矩阵点积结果之间的差异

00:03:25.085 --> 00:03:29.550
实际值是这个

00:03:29.550 --> 00:03:34.670
根据矩阵预测的值是

00:03:34.669 --> 00:03:39.679
左侧矩阵（用户矩阵）的第 i 行

00:03:39.680 --> 00:03:45.230
以及 V 矩阵（电影矩阵）的第 j 列

00:03:45.229 --> 00:03:50.185
预测值等于 user_mat[]...

00:03:50.185 --> 00:03:53.020
我们想要第 i 行

00:03:53.020 --> 00:03:56.380
所以是第 i 行和所有的列

00:03:56.379 --> 00:04:00.479
与电影矩阵的点积

00:04:00.479 --> 00:04:04.250
这样会获得所有的行

00:04:04.250 --> 00:04:07.689
但是我们只想第 j 列

00:04:07.689 --> 00:04:15.444
我们将在这里跟踪平方差之和

00:04:15.444 --> 00:04:18.740
如果我们希望每次迭代效果都更好

00:04:18.740 --> 00:04:22.170
这部分代码将很有用

00:04:22.170 --> 00:04:26.015
我们可以查看差值的平方和

00:04:26.014 --> 00:04:28.069
在更新流程中

00:04:28.069 --> 00:04:31.699
我们将查看该行的每项

00:04:31.699 --> 00:04:35.920
以及该列的每项

00:04:35.920 --> 00:04:38.765
即用户矩阵行中的每项

00:04:38.764 --> 00:04:41.810
和电影矩阵列中的每项

00:04:41.810 --> 00:04:44.660
然后根据梯度更新这些值

00:04:44.660 --> 00:04:50.950
梯度等于...

00:04:50.980 --> 00:04:57.240
原始值加上

00:04:57.240 --> 00:04:58.660
我将使用 +=

00:04:58.660 --> 00:05:00.200
即原始值

00:05:00.199 --> 00:05:10.514
加上学习速率乘以两倍的差值

00:05:10.514 --> 00:05:14.914
再乘以对立矩阵中相同位置的值

00:05:14.915 --> 00:05:17.280
查看之前的梯度公式

00:05:17.279 --> 00:05:18.509
会发现...

00:05:18.509 --> 00:05:19.860
用原始值...

00:05:19.860 --> 00:05:22.990
可以将这个公式写成

00:05:22.990 --> 00:05:27.259
user_mat[i, k] 等于原始的

00:05:27.259 --> 00:05:32.334
user_mat[i, k] 加上学习速率乘以两倍的差值

00:05:32.334 --> 00:05:33.944
我们在这里计算了差值

00:05:33.944 --> 00:05:35.474
再乘以对立矩阵（电影矩阵）中

00:05:35.475 --> 00:05:39.175
相同位置的值

00:05:39.175 --> 00:05:44.449
电影矩阵的更新公式很像

00:05:44.449 --> 00:05:47.365
但是

00:05:47.365 --> 00:05:50.174
我们需要的是第 k 个位置

00:05:50.173 --> 00:05:52.810
更新的是 [k, j] 位置

00:05:52.810 --> 00:05:55.555
加上学习速率乘以两倍的...

00:05:55.555 --> 00:05:59.915
这里必须是用户矩阵中的位置

00:05:59.915 --> 00:06:03.980
这个将是 [i, k]

00:06:03.980 --> 00:06:06.430
这就是更新流程

00:06:06.430 --> 00:06:08.569
最后

00:06:08.569 --> 00:06:11.189
我将写一个输出语句

00:06:16.360 --> 00:06:18.980
这里漏了 %

00:06:18.980 --> 00:06:29.069
这里应该是 user

00:06:29.069 --> 00:06:31.740
即对立矩阵

00:06:31.740 --> 00:06:35.490
这个应该是用户矩阵 而不是电影矩阵

00:06:38.660 --> 00:06:43.870
抱歉 我看到了 see 而不是 sse

00:06:46.160 --> 00:06:50.230
这个应该是 sum squared 的简写

00:06:54.949 --> 00:06:57.750
我找到 bug 了

00:06:57.750 --> 00:07:00.829
这个电影矩阵应该是

00:07:00.829 --> 00:07:04.829
潜在特征的数量 x 电影数量

00:07:08.060 --> 00:07:11.995
Great第一行应该是好几个 10

00:07:11.995 --> 00:07:15.194
可以看出很接近了

00:07:15.194 --> 00:07:17.449
这行应该是 8 9 10 5

00:07:17.449 --> 00:07:21.514
看起来差别有点大 等等

00:07:21.514 --> 00:07:23.750
如果使用 4 个潜在特征并且仅迭代 10 次

00:07:23.750 --> 00:07:27.180
收敛效果将不太好

00:07:27.180 --> 00:07:28.975
可以再试一遍

00:07:28.975 --> 00:07:32.865
使用相同的函数

00:07:32.865 --> 00:07:39.000
但是迭代 250 次 而不是 10 次

00:07:39.000 --> 00:07:41.670
这里要求迭代 250 次

00:07:41.670 --> 00:07:44.090
运行速度依然很快

00:07:44.089 --> 00:07:48.084
但是到后面出错了 有很多 0

00:07:48.084 --> 00:07:52.659
现在看看预测值与实际值

00:07:52.660 --> 00:07:54.415
它们基本一样

00:07:54.415 --> 00:07:56.720
只是一些小数差别

00:07:56.720 --> 00:08:01.620
下一步我们将在评分矩阵中添加一个 NaN 值

00:08:01.620 --> 00:08:04.610
我在第一部分添加了一个 NaN

00:08:04.610 --> 00:08:07.970
我们想看看是否依然能这么计算

00:08:07.970 --> 00:08:10.040
之前使用内置的函数

00:08:10.040 --> 00:08:13.879
计算奇异值分解结果时

00:08:13.879 --> 00:08:16.060
如果放入 NaN 值 代码将崩溃

00:08:16.060 --> 00:08:18.459
现在同样放入 NaN

00:08:18.459 --> 00:08:22.120
迭代 250 次

00:08:22.490 --> 00:08:25.835
代码能运行没有崩溃

00:08:25.834 --> 00:08:27.449
收敛效果很好

00:08:27.449 --> 00:08:30.985
甚至针对 NaN 所在的位置

00:08:30.985 --> 00:08:33.784
预测出 10.64 分

00:08:33.784 --> 00:08:36.110
实际上原来就是一个 10 分

00:08:36.110 --> 00:08:38.450
代码不仅能够

00:08:38.450 --> 00:08:41.915
预测出与实际值很接近的值

00:08:41.914 --> 00:08:44.929
而且当我们向矩阵中添加了 NaN 后

00:08:44.929 --> 00:08:46.024
代码没有崩溃

00:08:46.024 --> 00:08:50.000
所以我们的实现流程没有问题

