WEBVTT
Kind: captions
Language: zh-CN

00:00:05.480 --> 00:00:09.655
根据到目前为止所学的知识 你可能已经猜到了

00:00:09.654 --> 00:00:13.125
FunkSVD 是一种矩阵分解技巧

00:00:13.125 --> 00:00:16.289
适合解决这样的情形

00:00:16.289 --> 00:00:19.199
即矩阵中缺少很多值

00:00:19.199 --> 00:00:21.535
在出现 FunkSVD 方法之前

00:00:21.535 --> 00:00:26.179
通常大家采用的技巧是用 0 填充这些缺失的值

00:00:26.179 --> 00:00:29.189
但是 Simon 发现

00:00:29.190 --> 00:00:32.310
我们可以直接忽略这些缺失的值

00:00:32.310 --> 00:00:37.365
并找到仅仅使用已知值计算潜在因子的方法

00:00:37.365 --> 00:00:40.480
对于这种矩阵分解方法

00:00:40.479 --> 00:00:44.634
假设有两个矩阵 看起来和之前的很像

00:00:44.634 --> 00:00:47.339
一个矩阵是用户 x 潜在因子

00:00:47.340 --> 00:00:50.450
另一个是潜在因子 x 电影

00:00:50.450 --> 00:00:55.565
首先 在这些矩阵中随机地填充值

00:00:55.564 --> 00:00:57.199
暂时看起来没问题

00:00:57.200 --> 00:01:02.055
然后在用户-项目矩阵中搜索已经存在的评分

00:01:02.054 --> 00:01:04.034
找到一个评分后

00:01:04.034 --> 00:01:08.265
按照以下规则更新这些随机值

00:01:08.265 --> 00:01:12.649
我们将计算和用户相关的行

00:01:12.649 --> 00:01:14.980
与和电影相关的列之间的点积

00:01:14.980 --> 00:01:18.445
得出预测评分

00:01:18.444 --> 00:01:22.129
然后计算误差

00:01:22.129 --> 00:01:25.375
即实际评分与预测评分之间的差异

00:01:25.375 --> 00:01:29.480
我们的目标是通过更改每个矩阵中的权重

00:01:29.480 --> 00:01:34.050
最小化所有实际值的这个误差

00:01:34.049 --> 00:01:36.804
我们可以使用梯度下降法

00:01:36.805 --> 00:01:38.435
在用户矩阵中

00:01:38.435 --> 00:01:44.055
我们计算误差相对于 U 确定的每个值的导数

00:01:44.055 --> 00:01:46.515
同理 在电影矩阵中

00:01:46.515 --> 00:01:49.405
我们计算误差相对于 V 确定的每个值的导数

00:01:49.405 --> 00:01:53.594
然后使用这个链式法则

00:01:53.594 --> 00:01:58.885
得出最小化每个矩阵中的误差应该要朝的方向

00:01:58.885 --> 00:02:01.965
在每个求导公式里

00:02:01.965 --> 00:02:06.465
这部分表示实际值与预测值之间的差异

00:02:06.465 --> 00:02:10.849
我们现在可以使用这个更新每个矩阵中的值

00:02:10.849 --> 00:02:16.055
它们与最小化误差的步进方向相反

00:02:16.055 --> 00:02:20.939
下面我们对之前的矩阵进行一次梯度下降法迭代运算

00:02:20.939 --> 00:02:22.780
这些技巧到时候会有用的

00:02:22.780 --> 00:02:26.060
要更新用户矩阵

00:02:26.060 --> 00:02:29.280
我们需要查看用户矩阵的这一行

00:02:29.280 --> 00:02:33.754
这些值是在之前的方程中看到的 u 值

00:02:33.754 --> 00:02:36.250
我们还需要这些值

00:02:36.250 --> 00:02:39.544
它们位于电影矩阵的最后一列

00:02:39.544 --> 00:02:43.189
它们是之前公式里的 v 值

00:02:43.189 --> 00:02:46.780
新 u 值将是当前 u 值

00:02:46.780 --> 00:02:49.520
不过我们需要更新这个当前值

00:02:49.520 --> 00:02:52.400
更新方法是朝着

00:02:52.400 --> 00:02:54.670
这一项代表的梯度的相反方向移动

00:02:54.669 --> 00:02:58.934
但是不能移动太远

00:02:58.935 --> 00:03:04.004
通常会用一个学习速率朝着这个方向移动一小步

00:03:04.004 --> 00:03:09.789
称之为 α 将这一项放在要移动的方向前面

00:03:09.789 --> 00:03:13.625
我们根据这一规则更新第一个值

00:03:13.625 --> 00:03:16.985
更新规则是用当前值 0.8

00:03:16.985 --> 00:03:21.650
加上后面的部分

00:03:21.650 --> 00:03:24.145
学习速率假设为 0.01

00:03:24.145 --> 00:03:26.650
它可以是一个很小的数字

00:03:26.650 --> 00:03:28.610
用学习速率乘以

00:03:28.610 --> 00:03:32.625
实际值与预测值之间的差异的两倍

00:03:32.625 --> 00:03:35.280
我们之前已经算出这一项

00:03:35.280 --> 00:03:41.164
最后乘以同一潜在因子的对应 v 项

00:03:41.164 --> 00:03:44.495
这里是 -1.2

00:03:44.495 --> 00:03:48.655
新的 u 值为 0.59

00:03:48.655 --> 00:03:53.329
我们可以对每个 u 值应用相同的更新规则

00:03:53.329 --> 00:03:58.045
得出新的值分别为 1.39 和 -0.23

00:03:58.044 --> 00:04:01.625
我们还可以使用这个方程

00:04:01.625 --> 00:04:05.014
对 v 矩阵中的值进行相似的运算

00:04:05.014 --> 00:04:09.199
注意 u 矩阵中的新值已经对 v 矩阵中的新值

00:04:09.199 --> 00:04:13.544
产生影响 如这个方程所示

00:04:13.544 --> 00:04:16.654
这样我们就能更新所有 v 值

00:04:16.654 --> 00:04:21.399
我们可以用这些更新后的值替换 u 和 v 矩阵中的这些值

00:04:21.399 --> 00:04:23.995
这样的话 一次迭代就结束了

00:04:23.995 --> 00:04:26.350
接下来

00:04:26.350 --> 00:04:32.150
我们将寻找下个非缺失值 并再次更新 u 和 v 矩阵

00:04:32.149 --> 00:04:34.234
我们需要对所有非缺失值执行这一技巧

00:04:34.235 --> 00:04:39.045
并且很有可能迭代矩阵多次

00:04:39.045 --> 00:04:40.655
在下个 notebook 中

00:04:40.654 --> 00:04:42.904
你将自己实施这一技巧

00:04:42.904 --> 00:04:47.029
第一次练习这种算法可能会比较难

00:04:47.029 --> 00:04:48.424
如果你遇到问题

00:04:48.425 --> 00:04:50.360
请参阅解答 notebook

00:04:50.360 --> 00:04:53.720
我们将在其中演示求解过程加油！

