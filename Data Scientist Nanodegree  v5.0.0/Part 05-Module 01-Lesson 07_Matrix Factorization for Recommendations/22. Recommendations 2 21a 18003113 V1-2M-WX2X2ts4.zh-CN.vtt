WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:06.860
一种改进方式是使用基于内容和排名的方法

00:00:06.860 --> 00:00:10.080
这部分将读取

00:00:10.080 --> 00:00:13.798
我们在基于内容的指标部分编写的几个函数

00:00:13.798 --> 00:00:17.890
这个函数会根据你提供的电影查找相似电影

00:00:17.890 --> 00:00:22.230
这个函数会提取热门推荐电影

00:00:22.230 --> 00:00:24.870
我们的目标是

00:00:24.870 --> 00:00:28.500
使用之前用过的协同过滤方法

00:00:28.500 --> 00:00:35.090
以及基于内容和热门电影的方法做出推荐

00:00:35.090 --> 00:00:38.630
这是训练数据 train_data_df 是一个 DataFrame

00:00:38.630 --> 00:00:41.890
我们看看这个 DataFrame 的标头

00:00:43.689 --> 00:00:49.579
这个表格包含了所有可能的用户-电影组合

00:00:49.579 --> 00:00:53.774
我们希望对其中的每个用户做出推荐

00:00:53.774 --> 00:00:56.600
如果能使用 Funk SVD 我们将使用它

00:00:56.600 --> 00:01:01.385
如果能使用排名方法 我们将使用它

00:01:01.384 --> 00:01:03.140
我将在这里

00:01:03.140 --> 00:01:05.070
分两部分编写代码

00:01:05.069 --> 00:01:09.769
一部分基于 ID 类型进行推荐

00:01:09.769 --> 00:01:11.994
如果 ID 表示用户

00:01:11.995 --> 00:01:15.219
那么推荐技巧将与提供电影 ID 后

00:01:15.219 --> 00:01:18.549
采用的推荐技巧不同

00:01:18.549 --> 00:01:25.729
我首先创建了两个提供推荐内容的方法

00:01:25.730 --> 00:01:27.020
我先完成这部分

00:01:27.019 --> 00:01:29.099
因为这部分比较简单

00:01:29.099 --> 00:01:32.239
如果你提供给我电影推荐

00:01:32.239 --> 00:01:36.364
那么我将仅使用基于内容的推荐系统

00:01:36.364 --> 00:01:38.509
在这部分

00:01:38.510 --> 00:01:41.690
推荐的 ID 将等于

00:01:41.689 --> 00:01:45.984
根据你提供的 ID 查找相似的电影

00:01:45.984 --> 00:01:48.165
你需要提供电影 ID

00:01:48.165 --> 00:01:49.790
我将查找相似电影

00:01:49.790 --> 00:01:51.980
获取这些电影的片名

00:01:51.980 --> 00:01:54.109
并返回这些片名

00:01:54.109 --> 00:01:56.030
这个 finding_similar_movies 函数

00:01:56.030 --> 00:01:58.864
是我们之前使用的基于内容的推荐系统

00:01:58.864 --> 00:02:00.959
如果你提供了电影 ID...

00:02:00.959 --> 00:02:02.969
在这里有个类型变量

00:02:02.969 --> 00:02:04.530
如果你提供了电影 ID

00:02:04.530 --> 00:02:06.049
我将查找相似电影

00:02:06.049 --> 00:02:07.625
并向你推荐这些电影

00:02:07.625 --> 00:02:09.439
如果你提供了用户 ID

00:02:09.439 --> 00:02:13.069
那么我可以使用多种方法做出推荐

00:02:13.069 --> 00:02:14.620
我可以使用协同过滤

00:02:14.620 --> 00:02:16.680
使用基于排名的系统

00:02:16.680 --> 00:02:20.010
对于用户 ID 可以采用多种方法

00:02:20.009 --> 00:02:25.359
首先我进入用户矩阵中

00:02:25.360 --> 00:02:27.910
并获取索引

00:02:27.909 --> 00:02:30.919
我想知道它在什么位置

00:02:30.919 --> 00:02:33.934
实际上我多次使用了这种索引方法

00:02:33.935 --> 00:02:36.364
我将提取索引

00:02:36.364 --> 00:02:38.250
并存储到变量中

00:02:38.250 --> 00:02:40.780
然后

00:02:40.780 --> 00:02:46.099
我将根据两项的点积做出预测

00:02:46.099 --> 00:02:52.305
其中一个是用户矩阵

00:02:52.305 --> 00:02:56.210
我将获取用户所在的行和所有列

00:02:56.210 --> 00:03:00.950
这部分代码将从用户矩阵中获取与该用户相关的行

00:03:00.949 --> 00:03:04.534
并获取整个电影矩阵

00:03:04.534 --> 00:03:06.560
然后计算点积

00:03:06.560 --> 00:03:10.039
它将提供该用户的每部电影

00:03:10.039 --> 00:03:13.935
对应的预测评分

00:03:13.935 --> 00:03:18.390
我将计算用户矩阵与电影矩阵的点积

00:03:18.389 --> 00:03:20.114
但是在用户矩阵中

00:03:20.115 --> 00:03:22.670
仅获取该用户所在的行

00:03:22.669 --> 00:03:24.789
然后计算与电影矩阵的点积

00:03:24.789 --> 00:03:29.905
也就是使用 Funk SVD 创建预测

00:03:29.905 --> 00:03:32.449
然后根据从高到低顺序

00:03:32.449 --> 00:03:34.669
对预测排序

00:03:34.669 --> 00:03:38.629
这样会获得预测评分

00:03:38.629 --> 00:03:41.859
我只想获取并返回最高预测

00:03:41.860 --> 00:03:44.535
这就是我的预测方式

00:03:44.534 --> 00:03:49.699
我使用了 argsort() 来获取最高预测评分

00:03:49.699 --> 00:03:56.959
对这些项排序 然后提取所需数量的推荐内容

00:03:56.960 --> 00:03:58.230
我将这部分代码单独拿出来

00:03:58.229 --> 00:04:00.394
解释下代码的含义

00:04:00.395 --> 00:04:05.245
Idx 获取的是用户矩阵中与此用户相关的行

00:04:05.245 --> 00:04:07.814
如果 ID 等于 50

00:04:07.814 --> 00:04:10.794
我将从用户矩阵中找到该用户

00:04:10.794 --> 00:04:11.964
并提取该行

00:04:11.965 --> 00:04:14.215
然后计算它与用户矩阵的点积

00:04:14.215 --> 00:04:16.250
这样就会获得预测值

00:04:16.250 --> 00:04:19.490
这些评分是该用户对整个电影矩阵中的

00:04:19.490 --> 00:04:23.730
每部电影的预测评分

00:04:23.730 --> 00:04:26.045
这部分的作用是...

00:04:26.045 --> 00:04:28.660
我从 Stack Overflow 上找到了这些代码

00:04:28.660 --> 00:04:30.640
这部分的作用是

00:04:30.639 --> 00:04:36.729
对这些值排序并获取与这些电影相关的索引

00:04:36.730 --> 00:04:39.470
这部分会获取预测值

00:04:39.470 --> 00:04:43.880
将这部分代码单独拿出来

00:04:43.879 --> 00:04:49.310
它会按照预测值排序

00:04:49.310 --> 00:04:51.595
并返回索引

00:04:51.595 --> 00:04:54.350
这部分的作用是...

00:04:54.350 --> 00:04:57.085
传入一个数字例如 -10

00:04:57.084 --> 00:05:01.430
它会返回前 10 个值

00:05:01.430 --> 00:05:03.740
接下来

00:05:03.740 --> 00:05:05.129
我将颠倒顺序

00:05:05.129 --> 00:05:08.939
“::-1”的作用是颠倒顺序

00:05:08.939 --> 00:05:14.504
我们来看看这部分与这部分的区别

00:05:14.504 --> 00:05:16.560
如果你之前没见过的话 解释下

00:05:16.560 --> 00:05:23.175
这是一种颠倒顺序的小技巧

00:05:23.175 --> 00:05:25.160
之前顺序是这样的

00:05:25.160 --> 00:05:27.245
现在顺序是这样的

00:05:27.245 --> 00:05:29.709
顺序取决于之后如何通过索引访问它们

00:05:29.709 --> 00:05:34.819
因为我决定之后以特定的方式访问索引

00:05:34.819 --> 00:05:37.009
并以特定的顺序返回值 所以这么排序

00:05:37.009 --> 00:05:42.810
这部分将获取实际的片名

00:05:42.810 --> 00:05:46.024
Train_data_df.columns 是电影 ID

00:05:46.024 --> 00:05:50.404
这是与每个电影 ID 相关的索引

00:05:50.404 --> 00:05:53.250
我提取出这些电影 ID

00:05:53.250 --> 00:05:56.810
然后返回这些电影ID 对应的片名

00:05:56.810 --> 00:05:59.850
将这个称为 rec_names

00:05:59.850 --> 00:06:04.625
这些 rec_ids 和 rec_names 是一样的

00:06:04.625 --> 00:06:05.720
只不过一个针对的是

00:06:05.720 --> 00:06:07.340
提供电影 ID 的情形

00:06:07.339 --> 00:06:10.750
另一个针对的是提供用户 ID 的情形

00:06:10.750 --> 00:06:14.420
我发现在使用这个方法时

00:06:14.420 --> 00:06:18.590
有很多用户的预测是一样的

00:06:18.589 --> 00:06:23.369
也许这很准确 因为很多用户都喜欢这些电影

00:06:23.370 --> 00:06:25.970
但是从其他标准的角度来说

00:06:25.970 --> 00:06:30.080
我的推荐系统并不是太好

00:06:30.079 --> 00:06:33.594
例如意外新发现或发现怀旧电影

00:06:33.595 --> 00:06:37.940
希望你能自己创建一个推荐系统

00:06:37.939 --> 00:06:42.319
这些就是我结合基于内容的推荐方法和 Funk SVD 方法

00:06:42.319 --> 00:06:49.230
为用户和电影做出预测的流程 希望能对你有所启发

