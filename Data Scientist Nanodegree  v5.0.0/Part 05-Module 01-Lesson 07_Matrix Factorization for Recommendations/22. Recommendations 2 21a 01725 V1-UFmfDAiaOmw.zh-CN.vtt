WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:04.625
在此视频中 我们将在 Funk SVD 的基础上

00:00:04.625 --> 00:00:07.154
针对原本属于冷启动的情形

00:00:07.155 --> 00:00:11.445
作出预测

00:00:11.445 --> 00:00:16.094
在上个视频中我们发现

00:00:16.094 --> 00:00:20.655
如果某个用户或电影不在训练集中 但是出现在了测试集中

00:00:20.655 --> 00:00:23.390
我们将无法对其做出预测

00:00:23.390 --> 00:00:27.960
对于这些情形 我们将在此 notebook 中

00:00:27.960 --> 00:00:32.774
使用除 Funk SVD 以外的其他方法做出预测

00:00:32.774 --> 00:00:35.579
首先 我们将读取

00:00:35.579 --> 00:00:38.585
之前使用过的多项内容

00:00:38.585 --> 00:00:41.929
并且我将逐个介绍它们

00:00:41.929 --> 00:00:43.314
在第一部分

00:00:43.314 --> 00:00:45.224
我们将读取数据集

00:00:45.225 --> 00:00:48.664
我们将提取此 create_train_test

00:00:48.664 --> 00:00:50.869
你在之前的 notebook 中用过它

00:00:50.869 --> 00:00:53.024
还将提取 predict_rating

00:00:53.024 --> 00:00:58.195
它会使用上个 notebook 的 Funk SVD 提取预测

00:00:58.195 --> 00:01:00.035
我在下面

00:01:00.034 --> 00:01:05.159
创建了用户x电影矩阵

00:01:05.159 --> 00:01:08.814
我们在多个 notebook 中使用了该矩阵

00:01:08.814 --> 00:01:10.715
然后在下面

00:01:10.715 --> 00:01:13.040
我对在上个 notebook 中使用 Funk SVD

00:01:13.040 --> 00:01:17.490
创建的用户矩阵和电影矩阵调用了 pickle()

00:01:17.489 --> 00:01:21.089
现在我获取它们以便在此 notebook 中使用它们

00:01:21.090 --> 00:01:22.835
看看矩阵

00:01:22.834 --> 00:01:25.949
我在这创建一个单元格

00:01:25.950 --> 00:01:28.640
我们来看看用户矩阵

00:01:28.640 --> 00:01:30.430
这是用户矩阵

00:01:30.430 --> 00:01:32.990
看看形状更有用

00:01:32.989 --> 00:01:39.244
训练集有 3,278 个用户

00:01:39.245 --> 00:01:42.005
潜在特征是 15 个

00:01:42.004 --> 00:01:45.140
在电影矩阵中

00:01:45.140 --> 00:01:51.094
有 15 个特征和 2,679 部电影

00:01:51.094 --> 00:01:52.564
这是在之前的 notebook 中

00:01:52.564 --> 00:01:55.625
对训练集应用 Funk SVD 后获得的

00:01:55.625 --> 00:01:59.239
矩阵的电影数量和潜在特征数量

00:01:59.239 --> 00:02:01.549
我保存了这些数据

00:02:01.549 --> 00:02:04.265
这样就能在此 notebook 中提取并使用这些数据

00:02:04.265 --> 00:02:09.500
我们想要比较

00:02:09.500 --> 00:02:15.430
使用 Funk SVD 得出的每个预测值与真实值

00:02:15.430 --> 00:02:19.400
并返回一些指标 告诉我们 Funk SVD 的效果

00:02:19.400 --> 00:02:24.900
以及它针对特定的电影用户组合预测值是多少

00:02:24.900 --> 00:02:27.775
我创建了三个数组

00:02:27.775 --> 00:02:32.740
与在之前的 notebook 中使用的数组相似

00:02:32.740 --> 00:02:38.995
我获取了用户数组

00:02:38.995 --> 00:02:42.460
也就是提取了用户

00:02:42.460 --> 00:02:44.700
有必要看看 val_df

00:02:44.699 --> 00:02:46.769
这是验证数据

00:02:46.770 --> 00:02:50.344
我们将数据集拆分成了训练集和验证集

00:02:50.344 --> 00:02:53.930
val_df 是尚未传入

00:02:53.930 --> 00:02:59.349
Funk SVD 方法的用户和电影组合

00:02:59.349 --> 00:03:02.840
我们将对这些组合进行预测 看看效果

00:03:02.840 --> 00:03:10.219
我将提取 movie_id

00:03:10.219 --> 00:03:14.935
这部分代码看起来和之前的很像

00:03:14.935 --> 00:03:18.110
我们将传入索引

00:03:18.110 --> 00:03:21.260
并确保进入这些数组的正确位置

00:03:21.259 --> 00:03:27.500
然后从用户矩阵和电影矩阵提取正确的行列组合

00:03:27.500 --> 00:03:29.555
我在这里传入了这些项

00:03:29.555 --> 00:03:32.360
因为我们将计算用户行与电影列的点积

00:03:32.360 --> 00:03:39.070
从而做出预测

00:03:39.069 --> 00:03:42.109
我将创建几个

00:03:42.110 --> 00:03:45.240
在此函数中一直使用的其他变量

00:03:45.240 --> 00:03:47.064
一个是平方误差和 sse

00:03:47.064 --> 00:03:50.435
用 sse 跟踪平方误差

00:03:50.435 --> 00:03:54.289
并在做出其他预测时将平方误差加到这个变量上

00:03:54.289 --> 00:03:56.780
我还将记录评分数量

00:03:56.780 --> 00:03:59.344
一开始这个值为 0

00:03:59.344 --> 00:04:03.050
然后 我将跟踪预测值和真实值

00:04:03.050 --> 00:04:05.060
并将它们存储在列表中

00:04:05.060 --> 00:04:07.219
我创建了这个实际值与预测值相比变量

00:04:07.219 --> 00:04:08.500
它是这样的

00:04:08.500 --> 00:04:10.400
我将实际值放在一个轴上

00:04:10.400 --> 00:04:11.995
并将预测值放在另一个轴上

00:04:11.995 --> 00:04:14.730
然后创建一个热图

00:04:14.729 --> 00:04:20.019
看看实际值与预测值的比较情况

00:04:20.019 --> 00:04:22.214
对于 val_users 中的每一项

00:04:22.214 --> 00:04:24.379
我将使用这些项的索引

00:04:24.379 --> 00:04:27.245
然后转到不同的索引部分

00:04:27.245 --> 00:04:31.965
我将尝试使用 Funk SVD 做出预测

00:04:31.964 --> 00:04:35.299
但是如果预测失败

00:04:35.300 --> 00:04:39.020
我将抛出异常并继续转到下一项

00:04:39.019 --> 00:04:42.174
我将使用之前创建的 predict_rating 函数

00:04:42.175 --> 00:04:45.345
我将使用用户矩阵

00:04:45.345 --> 00:04:48.220
即通过 pickle() 从 Funk SVD 读取的矩阵

00:04:48.220 --> 00:04:50.915
这是通过 pickle() 读取的电影矩阵

00:04:50.915 --> 00:04:53.980
然后获取用户 ID 和电影 ID

00:04:53.980 --> 00:04:55.520
我将使用 idx

00:04:55.519 --> 00:05:01.979
从 val_users 的这一索引处提取值

00:05:01.980 --> 00:05:09.175
并从 val_movies 的这一索引处提取值 然后做出预测

00:05:09.175 --> 00:05:12.710
接下来 我将查看预测值

00:05:12.709 --> 00:05:17.149
与实际值相差多少

00:05:17.149 --> 00:05:20.224
用预测值减去实际值

00:05:20.225 --> 00:05:26.000
实际值等于该索引处的 val_ratings

00:05:26.000 --> 00:05:29.779
然后求平方 使它们都为正

00:05:29.779 --> 00:05:33.044
这就是平方误差和

00:05:33.045 --> 00:05:38.150
接着使评分数量 num_rated 加一

00:05:38.149 --> 00:05:40.764
注意 如果预测失败

00:05:40.764 --> 00:05:42.529
我们将转到 except 部分

00:05:42.529 --> 00:05:44.809
这时候 平方误差和不变

00:05:44.810 --> 00:05:48.535
评分数量也不会加一

00:05:48.535 --> 00:05:54.680
Ok然后将实际值附加到实际值列表上

00:05:54.680 --> 00:05:58.560
并将预测值附加到预测值列表上

00:05:58.560 --> 00:06:00.550
在这里附加预测值

00:06:00.550 --> 00:06:05.319
并在这里附加实际值

00:06:05.850 --> 00:06:10.695
然后在 actual_v_pred 中

00:06:10.694 --> 00:06:13.599
这里需要花点时间理解

00:06:13.600 --> 00:06:19.805
我将进入我创建的这个矩阵的索引中

00:06:19.805 --> 00:06:27.314
并在预测实际值所在的位置存储一个 1

00:06:27.314 --> 00:06:29.615
用图片展示会更好理解

00:06:29.615 --> 00:06:31.730
含义就是进入索引

00:06:31.730 --> 00:06:34.550
并在此位置加一

00:06:34.550 --> 00:06:41.750
这是一种比较复杂的确定索引方式 可以确定我要加一的具体位置

00:06:41.750 --> 00:06:46.899
当预测实际值落入 10 x 10 网格 我将加一

00:06:46.899 --> 00:06:50.579
然后更新 rmse

00:06:50.579 --> 00:06:58.779
它等于平方误差和除以评分数量

00:06:58.779 --> 00:07:03.559
然后跟踪评分百分比

00:07:03.560 --> 00:07:07.865
它等于评分数量除以 val_users 的长度

00:07:07.865 --> 00:07:09.790
这是用户总数

00:07:09.790 --> 00:07:12.770
我们将跟踪能够使用 SVD

00:07:12.769 --> 00:07:17.185
做出评分的用户所占的百分比

00:07:17.185 --> 00:07:20.319
接下来我们将看看这部分的效果

00:07:20.319 --> 00:07:22.925
复制这行代码

00:07:22.925 --> 00:07:29.509
并将这行代码放到这里 在中间添加一个等号

00:07:29.509 --> 00:07:31.764
之前出现了这种错误

00:07:31.764 --> 00:07:39.884
抱歉这个应该是 act_v_pred然后...

00:07:39.884 --> 00:07:43.769
这个也应该是 act_v_pred

00:07:43.769 --> 00:07:49.904
我输出了 rmse 和 perc_rated

00:07:49.904 --> 00:07:57.394
还创建了这个实际值与预测值比较热图

00:07:57.394 --> 00:08:00.930
然后在这里创建了大量其他标签

00:08:00.930 --> 00:08:04.269
这部分应该出错了

00:08:04.269 --> 00:08:11.379
这里应该是 val_ratings[idx] 减去...

00:08:11.379 --> 00:08:12.745
不应该出错的

00:08:12.745 --> 00:08:15.879
这里获取的是实际值

00:08:15.879 --> 00:08:18.245
即获取实际评分

00:08:18.245 --> 00:08:21.245
看看它在网格的什么位置再试一遍

00:08:21.245 --> 00:08:23.009
好的可以看出

00:08:23.009 --> 00:08:24.730
大部分点都落在这里

00:08:24.730 --> 00:08:26.819
预测值为 6

00:08:26.819 --> 00:08:29.389
实际值也为 6

00:08:29.389 --> 00:08:32.129
大部分评分都在这个范围内

00:08:32.129 --> 00:08:35.779
这个区域没有多少值

00:08:35.779 --> 00:08:38.824
我们可以看看其他矩阵

00:08:38.825 --> 00:08:42.035
所有这些评分相差约 2.04

00:08:42.034 --> 00:08:46.495
我们能够对大约 50% 的组合做出预测

00:08:46.495 --> 00:08:52.909
我们可以将可用的评分数量乘以 perc_rated

00:08:52.909 --> 00:08:59.875
看看我们的预测效果

00:08:59.875 --> 00:09:03.100
在已有数量的评分中

00:09:03.100 --> 00:09:06.835
我们能够对其中的 960 个做出预测

00:09:06.835 --> 00:09:11.335
同理 如果括号里是 1-perc_rated

00:09:11.335 --> 00:09:17.269
结果显示大约有 1,400 项无法做出预测

