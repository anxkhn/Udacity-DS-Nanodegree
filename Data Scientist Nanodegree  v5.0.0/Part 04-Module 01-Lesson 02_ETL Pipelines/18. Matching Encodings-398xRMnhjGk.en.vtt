WEBVTT
Kind: captions
Language: en

00:00:04.580 --> 00:00:09.525
How do computers store characters like the letters of the alphabet?

00:00:09.525 --> 00:00:12.960
Computers store everything as binary numbers.

00:00:12.960 --> 00:00:15.265
Lowercase a, for instance,

00:00:15.265 --> 00:00:21.140
might be stored as 01100001.

00:00:21.140 --> 00:00:24.780
But how does the computer go back and forth storing a in

00:00:24.780 --> 00:00:29.045
binary and then converting from binary to display the letter a?

00:00:29.045 --> 00:00:32.925
Computers do this conversion with encodings.

00:00:32.924 --> 00:00:36.349
Encodings are a set of rules for converting between

00:00:36.350 --> 00:00:40.530
characters and the binary representation of those characters.

00:00:40.530 --> 00:00:42.570
When the Internet first started,

00:00:42.570 --> 00:00:44.869
English was the most common language.

00:00:44.869 --> 00:00:48.873
Hence, the most common encoding back then called ASCII,

00:00:48.874 --> 00:00:50.750
was specific to English.

00:00:50.750 --> 00:00:52.820
As the Internet proliferated,

00:00:52.820 --> 00:00:56.014
ASCII couldn't handle all of the world's languages.

00:00:56.014 --> 00:01:01.160
Many languages contain more than the 26 characters in the English alphabet.

00:01:01.159 --> 00:01:05.569
Some Asian languages have thousands of unique characters.

00:01:05.569 --> 00:01:10.579
An international organization called the Unicode Consortium has created some

00:01:10.579 --> 00:01:15.789
of the most flexible and comprehensive encodings to cover the world's languages.

00:01:15.790 --> 00:01:20.425
Most of the data you'll come across is encoded with one of their encodings,

00:01:20.424 --> 00:01:23.284
especially one called UTF-8.

00:01:23.284 --> 00:01:30.049
However, you'll also come across datasets with other encodings like GB2312,

00:01:30.049 --> 00:01:32.108
for simplified Chinese characters,

00:01:32.108 --> 00:01:36.504
and latin-1 for languages that use the Latin alphabet.

00:01:36.504 --> 00:01:39.859
The problem is that it's not easy to tell

00:01:39.859 --> 00:01:43.429
how a dataset was encoded unless somebody tells you.

00:01:43.430 --> 00:01:47.495
That's where the next programming exercise comes into play.

00:01:47.495 --> 00:01:51.170
I provided a dataset with a mystery encoding.

00:01:51.170 --> 00:01:54.924
Your job will be to figure out what encoding was used.

00:01:54.924 --> 00:01:57.390
This might seem like I'm being mean,

00:01:57.390 --> 00:02:01.265
but figuring out encodings is a real world problem.

00:02:01.265 --> 00:02:07.064
As you'll see, you can't read in a CSV file if you do not know the encoding.

00:02:07.064 --> 00:02:10.294
In the exercise, you'll use the Panda's package

00:02:10.294 --> 00:02:14.299
alongside a list of the encodings that come with the Python installation.

00:02:14.300 --> 00:02:18.000
Check out the next part of the lesson to get started.

