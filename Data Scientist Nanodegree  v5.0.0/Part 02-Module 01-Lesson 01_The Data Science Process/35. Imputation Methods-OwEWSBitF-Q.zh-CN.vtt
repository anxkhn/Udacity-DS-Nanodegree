WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.810
在这个视频里 我们来看几种填充缺失值的方法

00:00:03.810 --> 00:00:09.060
这里可以看到几种非常常见的填充缺失值方法

00:00:09.060 --> 00:00:11.700
这里是几个非常有用的资料链接

00:00:11.699 --> 00:00:14.324
位于 Notebook 最上面的单元格中

00:00:14.324 --> 00:00:20.189
首先创建数据集 然后导入需要的库

00:00:20.190 --> 00:00:23.330
在这个示例中

00:00:23.329 --> 00:00:27.299
我们使用 Pandas 来填充缺失值 而不是 scikit-learn

00:00:27.300 --> 00:00:30.539
但是 scikit-learn 的 pre-processing 库真的很有用

00:00:30.539 --> 00:00:33.960
经常和其他机器学习算法一起使用

00:00:33.960 --> 00:00:38.100
Pandas 也是非常直观、易用的库

00:00:38.100 --> 00:00:41.984
所以我们会在这个示例中使用 Pandas

00:00:41.984 --> 00:00:43.259
不过 你也可以选择

00:00:43.259 --> 00:00:46.994
使用 pre-processing 库 如果你对其更加熟悉

00:00:46.994 --> 00:00:49.214
第一个问题是

00:00:49.215 --> 00:00:52.855
用下面的字典 标注出每列对应的数据类型

00:00:52.854 --> 00:00:55.164
看一下数据

00:00:55.164 --> 00:01:00.464
列 A 看上去是数值型的

00:01:00.465 --> 00:01:02.625
列 B 也是数值型的

00:01:02.625 --> 00:01:07.165
但是 A 更像是浮点数

00:01:07.165 --> 00:01:09.105
而 B 则是整数

00:01:09.105 --> 00:01:10.865
C 全是缺失值

00:01:10.864 --> 00:01:13.559
也就是说 它可以是任意类型

00:01:13.560 --> 00:01:16.454
D 看上去是 布尔值

00:01:16.454 --> 00:01:20.064
E 看上去像是分类变量

00:01:20.064 --> 00:01:22.109
其中有 Yes、No 和 Maybe 这些类别

00:01:22.109 --> 00:01:26.204
现在对下面的字典进行填充

00:01:26.204 --> 00:01:28.920
A 是数值型的

00:01:28.920 --> 00:01:32.430
B 也是数值型的

00:01:32.430 --> 00:01:36.190
C 不知道是哪种类型 因为全都是 NaN

00:01:36.189 --> 00:01:41.009
D 是布尔型的 但我们也可以将其处理为其他类型

00:01:41.010 --> 00:01:42.570
可以将其看作 1/0 这样的数值类型

00:01:42.569 --> 00:01:46.844
True/False 也可以是 yes/no 这样的形式

00:01:46.844 --> 00:01:49.209
可以转换为任意一种形式

00:01:49.209 --> 00:01:50.804
但确实也是布尔值

00:01:50.805 --> 00:01:54.245
E 是一个分类变量

00:01:54.245 --> 00:01:58.560
好了 通过了

00:01:58.560 --> 00:02:03.010
数据中有没有可以放心删除的行或列?

00:02:03.010 --> 00:02:07.770
总的来说 我们完全可以放心地删除 C 列

00:02:07.769 --> 00:02:12.384
但行里面 没有哪行是全都缺失的

00:02:12.384 --> 00:02:14.745
所以 我们可能并不想删除哪一行

00:02:14.745 --> 00:02:20.085
但一定可以删除这里的 C 列

00:02:20.085 --> 00:02:21.795
我们实际删除一下

00:02:21.794 --> 00:02:23.804
创建了一个新的 DataFrame new_df

00:02:23.805 --> 00:02:25.890
用 drop 函数删除 C 列

00:02:25.889 --> 00:02:30.250
让 axis 等于 1 指定删除的是列而不是行

00:02:30.250 --> 00:02:32.870
接下来使用 new_df

00:02:32.870 --> 00:02:35.640
我编写了一个 lambda 函数 用均值填充缺失值

00:02:35.639 --> 00:02:39.039
可以通过 apply 方法应用到 new_df 的各列

00:02:39.039 --> 00:02:44.185
这里基本上就是用 col.mean()

00:02:44.185 --> 00:02:48.974
fillna 函数 沿着行的方向依次应用

00:02:48.974 --> 00:02:51.579
fillna 函数 沿着行的方向依次应用

00:02:51.580 --> 00:02:55.950
没有运行成功 将下面的选项填到相应的位置

00:02:55.949 --> 00:02:57.899
为什么报错了呢?

00:02:57.900 --> 00:03:00.539
我们获取每列

00:03:00.539 --> 00:03:04.812
取其均值 之后用均值对列中的缺失值进行填充

00:03:04.812 --> 00:03:09.799
对数据中的每一列都应用这个函数

00:03:09.800 --> 00:03:11.186
选项 a "用均值填充 但是在这种情况下没有现实意义"

00:03:11.186 --> 00:03:12.974
选项 a "用均值填充 但是在这种情况下没有现实意义"

00:03:12.974 --> 00:03:17.900
选项 b "返回了一个错误" 好的 我们来看一下每一列的情况

00:03:17.900 --> 00:03:20.555
假设我们要用均值来填充这些缺失值

00:03:20.555 --> 00:03:24.194
如果用均值填充这一列 不会有什么问题

00:03:24.194 --> 00:03:26.477
因为会取这里的 2、0、7、10、15 的均值

00:03:26.477 --> 00:03:29.634
然后把均值填充在这两个 NaN 的位置上

00:03:29.634 --> 00:03:33.174
B 列其实并没有任何缺失值 所以不用考虑

00:03:33.175 --> 00:03:36.300
C 列 其实根本不知道能填充什么

00:03:36.300 --> 00:03:40.365
因为其中根本就没有任何数值可以计算

00:03:40.365 --> 00:03:44.445
D 列 如果把这些值当作数字的话

00:03:44.444 --> 00:03:47.324
应该能返回均值 0.5

00:03:47.324 --> 00:03:49.799
但是 对于 True/False 来说 0.5 意味着什么?

00:03:49.800 --> 00:03:52.064
这样并没有现实意义

00:03:52.064 --> 00:03:53.639
所以 D 用均值填充没什么意义

00:03:53.639 --> 00:03:55.539
C 不是很确定

00:03:55.539 --> 00:03:57.054
A 应该是没问题的

00:03:57.055 --> 00:03:58.980
然后是 E

00:03:58.979 --> 00:04:02.924
我不知道这里的均值如何计算 因为只有 Yes、No 和 Maybe

00:04:02.925 --> 00:04:05.785
不确定这里如何用均值填充

00:04:05.784 --> 00:04:10.424
用均值填充缺失值 唯一有意义的是 A 列

00:04:10.425 --> 00:04:12.105
C 列 我们其实已经删除了

00:04:12.104 --> 00:04:13.479
所以不需要去考虑

00:04:13.479 --> 00:04:16.295
A 是可以的

00:04:16.295 --> 00:04:19.379
应该是选项 c "没有问题 该列可以按预期用均值填充"

00:04:19.379 --> 00:04:21.555
应该是选项 c "没有问题 该列可以按预期用均值填充"

00:04:21.555 --> 00:04:24.014
E 是 Yes、No 和 Maybe 所在列

00:04:24.014 --> 00:04:26.300
这一列很可能会报错

00:04:26.300 --> 00:04:29.100
因为不知道这个均值到底该如何计算

00:04:29.100 --> 00:04:30.930
然后是 True/False 所在列

00:04:30.930 --> 00:04:33.704
虽然也可以用均值填充 也就是 0.5

00:04:33.704 --> 00:04:35.490
但是 0.5 对于 True/False 来说是什么意思?

00:04:35.490 --> 00:04:37.379
其实并没有现实意义

00:04:37.379 --> 00:04:39.993
这里 还可以看到一些额外的评论

00:04:39.994 --> 00:04:43.155
确保你真的理解了这个练习的答案

00:04:43.154 --> 00:04:47.019
只有第一列是可以用均值来填充缺失值的

00:04:47.019 --> 00:04:49.544
True/False 的列的均值是 0.5

00:04:49.545 --> 00:04:53.490
但是这个值对于 True/False 来说没有意义

00:04:53.490 --> 00:04:56.574
B 列直接会报错 (此处口误 应该是 E 列)

00:04:56.574 --> 00:05:00.444
因为不能对分类变量求均值

00:05:00.444 --> 00:05:02.449
看了上面的结果

00:05:02.449 --> 00:05:05.550
某些列用众数来填充可能更有意义

00:05:05.550 --> 00:05:09.060
自己编写一个函数 用众数填充缺失值

00:05:09.060 --> 00:05:13.456
这里还有一处参考资料链接

00:05:13.456 --> 00:05:19.099
好像可以这样来获取众数

00:05:19.100 --> 00:05:20.645
对每一列

00:05:20.644 --> 00:05:24.310
我们可以通过这种方式获取众数

00:05:24.310 --> 00:05:26.485
回到练习中

00:05:26.485 --> 00:05:29.764
将这个函数叫做 fill_mode

00:05:29.764 --> 00:05:35.750
其实是跟之前的 lambda 表达式非常相似的

00:05:35.750 --> 00:05:39.620
直接复制过来

00:05:39.620 --> 00:05:41.689
如果要用众数填充的话

00:05:41.689 --> 00:05:48.689
主要就是用到刚才看到的代码

00:05:48.689 --> 00:05:52.219
调用 fillna 函数

00:05:52.220 --> 00:05:58.055
然后调用 mode 函数

00:05:58.055 --> 00:06:03.314
不过好像与 mean 有点不同

00:06:03.314 --> 00:06:07.800
他们先对列调用 mode() 然后再取索引 0 的值

00:06:07.800 --> 00:06:12.754
所以 我们也要这样做

00:06:12.754 --> 00:06:16.904
将下面改为 fill_mode

00:06:16.904 --> 00:06:19.274
好了 现在来看一下

00:06:19.274 --> 00:06:22.742
我们的数据集 new_df1

00:06:22.742 --> 00:06:25.728
好的

00:06:25.728 --> 00:06:28.144
我们来看一下

00:06:28.144 --> 00:06:32.495
A 这一列的众数

00:06:32.495 --> 00:06:34.399
因为该列其实并不存在众数

00:06:34.399 --> 00:06:37.739
所以程序就把 0 作为众数进行了填充

00:06:37.740 --> 00:06:40.910
但是 0 其实并不是真正的众数

00:06:40.910 --> 00:06:43.040
它只是其中的一个值

00:06:43.040 --> 00:06:45.995
所以 我会在这边填 a

00:06:45.995 --> 00:06:53.870
这一列没有众数 所以好像就只是选了其中一个数字

00:06:53.870 --> 00:06:56.000
我也不是特别清楚是如何选择的

00:06:56.000 --> 00:06:59.055
回头可以查一下 mode 的文档

00:06:59.055 --> 00:07:01.560
关于 D 列

00:07:01.560 --> 00:07:03.214
这里也比较有趣

00:07:03.214 --> 00:07:05.479
这一列也没有填充均值

00:07:05.480 --> 00:07:08.004
因为这一列的 True 和 False 的数量是相同的

00:07:08.004 --> 00:07:10.465
看一下上面的数据

00:07:10.464 --> 00:07:13.209
这一列有两个 False 两个 True

00:07:13.209 --> 00:07:15.424
两个 True 两个 False

00:07:15.425 --> 00:07:20.595
结果用 False 填充了缺失值

00:07:20.595 --> 00:07:23.217
也就是说 这一列也没有众数

00:07:23.216 --> 00:07:29.104
好像就是选出了 False 来填充这些缺失值

00:07:29.105 --> 00:07:32.705
有可能文档里面这样规定

00:07:32.704 --> 00:07:33.769
如果所有值的的频数相同 选择最小的数字

00:07:33.769 --> 00:07:39.168
如果所有值的的频数相同 选择最小的数字

00:07:39.168 --> 00:07:44.840
因为 False 也会被当作 0

00:07:44.839 --> 00:07:46.769
所以这里也相当于填充的是 0

00:07:46.769 --> 00:07:48.049
但不管是什么情况

00:07:48.050 --> 00:07:50.720
这两列并没有真正用众数填充

00:07:50.720 --> 00:07:54.500
对于最后一列 回到之前的数据

00:07:54.500 --> 00:07:58.129
可以看到 Yes 出现的要比 No 和 Maybe 多

00:07:58.129 --> 00:08:01.279
有两个 Yes、一个 No、一个 Maybe

00:08:01.279 --> 00:08:02.824
至少在这一列 如果填充的值是 Yes

00:08:02.824 --> 00:08:05.045
就说明确实用众数来填充的

00:08:05.045 --> 00:08:08.689
也就是说 用出现次数最多的值进行了填充

00:08:08.689 --> 00:08:15.187
对于分类变量 的确有填充众数

00:08:15.187 --> 00:08:18.050
这是对的

00:08:18.050 --> 00:08:21.170
再次强调 用均值填充

00:08:21.170 --> 00:08:24.555
缺失值的时候 我们要非常小心 因为有一些情况会报错

00:08:24.555 --> 00:08:25.819
用众数填充时

00:08:25.819 --> 00:08:33.169
有一些情况虽然看似可行 但是并没有实际意义

00:08:33.169 --> 00:08:36.094
即使确实可以填充 获得一种结果

00:08:36.095 --> 00:08:41.019
但很可能也并不是最佳解决方案

