WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.910
目前为止 你已经对处理缺失值积累了

00:00:02.910 --> 00:00:06.935
一定的经验 使用过常用方法填充缺失值

00:00:06.934 --> 00:00:10.469
在这个视频当中

00:00:10.470 --> 00:00:12.675
我们来看一下 填充缺失值

00:00:12.675 --> 00:00:16.365
会不会比直接删除缺失值的效果更好

00:00:16.364 --> 00:00:20.549
之前直接删除的一个很大的问题就是

00:00:20.550 --> 00:00:24.074
我们实际上并没有针对所有的值进行预测

00:00:24.074 --> 00:00:30.179
因为只要缺少某个 X 矩阵中的值

00:00:30.179 --> 00:00:32.564
就没办法对其做出预测了

00:00:32.564 --> 00:00:34.974
我们就直接将这些值从数据集中删除

00:00:34.975 --> 00:00:40.170
但如果对缺失值进行填充

00:00:40.170 --> 00:00:43.945
就可以在完整的数据上做出预测

00:00:43.945 --> 00:00:47.939
这里能够看到 之前使用删除缺失值方法得到的结果

00:00:47.939 --> 00:00:51.006
这里能够看到 之前使用删除缺失值方法得到的结果

00:00:51.006 --> 00:00:57.754
现在来看一下 如果我们遵循提示 能否获得更好的结果

00:00:57.755 --> 00:01:04.725
将 num_vars 中 Salary 缺失的数据删除

00:01:04.724 --> 00:01:07.484
用均值来填充其他列的缺失值

00:01:07.484 --> 00:01:10.250
删除缺失工资的行

00:01:10.250 --> 00:01:13.905
使用 num_vars DataFrame

00:01:13.905 --> 00:01:16.034
删除缺失值

00:01:16.034 --> 00:01:21.689
删除目标变量缺失的数据行

00:01:21.689 --> 00:01:25.265
使用 num_vars

00:01:25.265 --> 00:01:33.450
调用 dropna 将 subset 设为 Salary

00:01:33.450 --> 00:01:37.189
我们想要删除相关的数据行

00:01:37.189 --> 00:01:39.524
也就是 axis 要等于 0

00:01:39.525 --> 00:01:42.045
将缺少工资的行删除

00:01:42.045 --> 00:01:46.045
来看一下结果 看上去似乎不错

00:01:46.045 --> 00:01:48.135
然后再用这个来检查一下

00:01:48.135 --> 00:01:54.510
这里 我们要把所有缺失值的地方用均值来填充

00:01:54.510 --> 00:01:57.050
来看一下

00:01:57.049 --> 00:02:00.375
我们可以复用之前的代码

00:02:00.375 --> 00:02:05.219
也就是 fill_mean = lambda col: col.fillna(col.mean())

00:02:05.219 --> 00:02:14.397
也就是 fill_mean = lambda col: col.fillna(col.mean())

00:02:14.397 --> 00:02:17.290
我们取某一列的均值

00:02:17.290 --> 00:02:20.614
然后将其填充到该列缺失值的位置

00:02:20.614 --> 00:02:38.414
再用 drop_sal_df.apply(fill_mean, axis=1)

00:02:38.414 --> 00:02:41.655
看看对不对

00:02:41.655 --> 00:02:42.840
结果与预期不相符

00:02:42.840 --> 00:02:45.254
再试下 axis = 0

00:02:45.254 --> 00:02:47.299
看看结果

00:02:47.300 --> 00:02:50.210
是的 axis 的确要等于 0

00:02:50.210 --> 00:02:53.724
我们实际计算的是每一列的均值 有点说不通

00:02:53.724 --> 00:02:56.634
不过我经常会弄混

00:02:56.634 --> 00:02:58.689
所以把 axis 设为 0

00:02:58.689 --> 00:03:02.658
就可以看到缺失值被填充了

00:03:02.658 --> 00:03:03.883
这些不应该改变

00:03:03.883 --> 00:03:07.719
这里我用了周工作时长的均值

00:03:07.719 --> 00:03:11.759
大家平均的周工作时长似乎是 2.44

00:03:11.759 --> 00:03:15.891
但如果让 axis 等于 0 的话 我们会看到

00:03:15.891 --> 00:03:18.879
的确 这看上去就不合理了

00:03:18.879 --> 00:03:21.210
28000 一周

00:03:21.210 --> 00:03:22.985
这也太多了

00:03:22.985 --> 00:03:25.098
所以不合理

00:03:25.098 --> 00:03:27.030
如果我们这样做

00:03:27.030 --> 00:03:29.844
就能得到每一列的均值

00:03:29.844 --> 00:03:31.419
接下里的问题是

00:03:31.419 --> 00:03:35.254
用 fill_df 中的数值变量来预测工资

00:03:35.254 --> 00:03:39.954
这里的思路是 对缺失值进行填充

00:03:39.955 --> 00:03:43.760
而不像之前做的那样 直接都删除掉

00:03:43.759 --> 00:03:46.294
我们现在应该可以预测这些工资

00:03:46.294 --> 00:03:49.000
之前的模型是不可以的

00:03:49.000 --> 00:03:52.745
因为这些数据中都存在缺失值

00:03:52.745 --> 00:03:56.620
之前我们实际上直接将这些数据删除了

00:03:56.620 --> 00:03:59.200
但现在我们已经填充了这些值

00:03:59.199 --> 00:04:04.030
尽管我们只是用均值做的填充 应该也是可以做预测的

00:04:04.030 --> 00:04:08.069
将数据划分为解释变量 X 和目标变量 y

00:04:08.069 --> 00:04:15.549
仍然将其命名为 X 等于从 fillna 中筛选出所有数值变量

00:04:15.550 --> 00:04:23.816
y = fill_df['Salary']

00:04:23.815 --> 00:04:28.750
这里只是把目标变量从数据集中拆分出来

00:04:28.750 --> 00:04:31.420
然后还要把它们分成训练集和测试集

00:04:31.420 --> 00:04:37.610
我经常忘记这个要怎么写 还好上面有例子

00:04:37.610 --> 00:04:41.199
这里的很多代码都可以复用

00:04:41.199 --> 00:04:44.289
创建 X 和 y 之后

00:04:44.290 --> 00:04:46.405
将 X 和 y 传入这个函数

00:04:46.404 --> 00:04:48.454
这个也需要 这个也需要

00:04:48.454 --> 00:04:50.074
所有这些都可以复用

00:04:50.074 --> 00:04:53.043
给出的名称也是一样的

00:04:53.043 --> 00:04:56.057
R 平方值的变量名是 rsquared_score

00:04:56.057 --> 00:04:57.935
我们可以获取到

00:04:57.935 --> 00:05:00.490
然后还需要 length_y_test

00:05:00.490 --> 00:05:10.995
也就是 len(y_test_preds) 然后 R 平方应该是这里

00:05:10.995 --> 00:05:16.393
这两个值应该就是题目要求的

00:05:16.392 --> 00:05:20.719
我们还是需要做预测 给出评分

00:05:20.720 --> 00:05:28.535
预测并评分 然后还要求展示出样本的数量

00:05:28.535 --> 00:05:31.280
把这些代码都放到一起

00:05:31.279 --> 00:05:38.514
这样看上去 我们对 1503 条数据进行了预测 比之前的 645 要多

00:05:38.514 --> 00:05:41.009
之前只有 2% 的差异性得到了解释 现在有 3.2% 了

00:05:41.009 --> 00:05:47.000
之前只有 2% 的差异性得到了解释 现在有 3.2% 了

