WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:05.535
现在是第二个解决方案视频 针对如何入门这一问题

00:00:05.535 --> 00:00:08.220
如果这是我们感兴趣的问题

00:00:08.220 --> 00:00:12.835
应该如何分析数据得出结论呢?

00:00:12.835 --> 00:00:14.430
第一个问题是

00:00:14.429 --> 00:00:16.774
为了理解如何入门这个问题

00:00:16.774 --> 00:00:19.000
需要先理解 CousinEducation 特征列

00:00:19.000 --> 00:00:21.929
使用 schema 数据集来回答这一问题

00:00:21.929 --> 00:00:24.689
完成这个名为 get_description 的函数

00:00:24.690 --> 00:00:30.075
其参数为 schema DataFrame 以及字符串形式的列名 返回对该列的描述

00:00:30.074 --> 00:00:34.990
schema 就是这里读入的数据集

00:00:34.990 --> 00:00:38.460
这里读入了两个数据集

00:00:38.460 --> 00:00:43.439
再次导入了很多库 以及 test1.py 测试文件

00:00:43.439 --> 00:00:45.269
帮助我们检查代码

00:00:45.270 --> 00:00:50.065
schema 是接下来会用到的数据集

00:00:50.064 --> 00:00:52.530
我们可以在这里

00:00:52.530 --> 00:00:54.495
再次插入一个单元格

00:00:54.494 --> 00:00:56.804
再次插入一个单元格

00:00:56.804 --> 00:01:01.369
快速浏览一下 schema 数据集

00:01:01.369 --> 00:01:04.120
可以看到 Column 列以及 Question 列

00:01:04.120 --> 00:01:07.665
我们要做的是

00:01:07.665 --> 00:01:11.063
输入列名字符串

00:01:11.063 --> 00:01:15.105
返回其对应的描述

00:01:15.105 --> 00:01:16.523
描述就是 Question 列中的内容

00:01:16.522 --> 00:01:18.269
描述就是 Question 列中的内容

00:01:18.269 --> 00:01:20.174
而列名就在这里的 Column 列中

00:01:20.174 --> 00:01:23.459
也就是说

00:01:23.459 --> 00:01:27.242
使用 schema 参数

00:01:27.242 --> 00:01:28.991
也就是其中一个输入参数

00:01:28.992 --> 00:01:37.030
我们需要 Column 等于 column_name

00:01:37.030 --> 00:01:39.750
如果判断为 True

00:01:39.750 --> 00:01:42.915
就是要筛选出 schema 中 Column 列的值等于 column_name 的数据

00:01:42.915 --> 00:01:50.205
就是要筛选出 schema 中 Column 列的值等于 column_name 的数据

00:01:50.204 --> 00:01:54.215
返回该行数据对应的 Question 列的内容

00:01:54.215 --> 00:01:58.155
再来看一下代码具体的作用

00:01:58.155 --> 00:02:02.909
我想要到 schema 数据集中 找到 Column 列中

00:02:02.909 --> 00:02:08.544
等于输入的列名的数据 然后给出其对应的描述部分

00:02:08.544 --> 00:02:10.419
希望这是对的

00:02:10.419 --> 00:02:14.139
如果是对的……

00:02:14.139 --> 00:02:16.004
噢 有错误

00:02:16.004 --> 00:02:21.794
某个 schema 拼错了

00:02:21.794 --> 00:02:23.519
好了 可以看到

00:02:23.520 --> 00:02:28.419
这个描述是问卷参与者的 ID 可以对照答案检查一下

00:02:28.419 --> 00:02:31.360
噢 又不行

00:02:31.360 --> 00:02:37.560
这里的报错说 Series 是可变类型 不能进行哈希

00:02:37.560 --> 00:02:47.045
我们可以回到这里 打开 solution 文件

00:02:47.044 --> 00:02:50.055
看一下答案

00:02:50.056 --> 00:02:55.260
他们先把结果转换成列表 然后再提取

00:02:55.259 --> 00:02:58.985
回到刚才的练习中 再来试一下

00:02:58.985 --> 00:03:06.120
答案说要转换为列表再提取

00:03:06.120 --> 00:03:08.685
然后就只有描述字符串的部分了

00:03:08.685 --> 00:03:11.385
奇怪 为什么呢?

00:03:11.385 --> 00:03:21.764
试一下 schema[schema['Column'] == 'Country']

00:03:21.764 --> 00:03:27.066
试一下 schema[schema['Column'] == 'Country']

00:03:27.067 --> 00:03:29.804
然后再选出对应的 Question 列

00:03:29.804 --> 00:03:34.270
然后再选出对应的 Question 列

00:03:34.270 --> 00:03:37.335
这样就返回了之前奇怪的数据形式

00:03:37.335 --> 00:03:40.194
如果将其转换为列表

00:03:40.193 --> 00:03:42.524
里面就只剩了一个字符串

00:03:42.525 --> 00:03:45.300
给定一个类似 Pandas DataFrame 的数据 将其转换成列表

00:03:45.300 --> 00:03:46.380
就得出了这样的结果

00:03:46.379 --> 00:03:49.990
这样索引 0 就能将其中的字符串提取出来

00:03:49.990 --> 00:03:55.375
这句代码比较绕

00:03:55.375 --> 00:03:59.680
好了 我们想要解决的问题是

00:03:59.680 --> 00:04:01.300
如何入门技术领域

00:04:01.300 --> 00:04:04.490
也就是这一列 (CousinEducation)

00:04:04.490 --> 00:04:08.015
这里就可以看到其对应的描述了

00:04:08.014 --> 00:04:11.259
仔细阅读这段文字

00:04:11.259 --> 00:04:17.430
可以更好地理解 为什么该列对了解如何入门有帮助

00:04:17.430 --> 00:04:19.060
这里的 core_ed_vals 表示

00:04:19.060 --> 00:04:24.024
包含 CousinEducation 列每种类别数量的 Pandas Series

00:04:24.024 --> 00:04:25.462
确保数据展示正确

00:04:25.463 --> 00:04:34.700
代码是 df['CousinEducation'].value_counts()

00:04:34.699 --> 00:04:40.834
要确保结果是可行的

00:04:40.834 --> 00:04:43.685
你会发现 结果看上去并不太好

00:04:43.685 --> 00:04:45.079
比如这些

00:04:45.079 --> 00:04:47.680
如果一个人给出多条建议

00:04:47.680 --> 00:04:49.723
这些建议就都被放在一起了

00:04:49.723 --> 00:04:51.980
比如 这个人给出了三条建议

00:04:51.980 --> 00:04:55.920
这个人给出了四条建议 都列出来了

00:04:55.920 --> 00:05:02.020
而且不只是一个人 有 132 人都给出了这些建议、140 人给出了这些建议

00:05:02.019 --> 00:05:07.043
如果我们用图表展示这个结果

00:05:07.043 --> 00:05:09.230
如果我们用图表展示这个结果

00:05:09.230 --> 00:05:12.230
效果应该不会太好

00:05:12.230 --> 00:05:16.275
绘图可能需要很长时间 因为有很多数据

00:05:16.274 --> 00:05:18.354
所以不应该这样做

00:05:18.355 --> 00:05:21.384
我们想要的其实是把不同的建议分开来

00:05:21.384 --> 00:05:26.514
一个柱形代表一个建议

00:05:26.514 --> 00:05:29.394
你可以看到 这个图表没有任何用处

00:05:29.394 --> 00:05:30.877
没办法观察到任何信息

00:05:30.877 --> 00:05:35.224
这里是所有可能给出的建议选项

00:05:35.225 --> 00:05:37.540
我们想要的是一个柱形只代表一个建议

00:05:37.540 --> 00:05:40.903
有多少人推荐了这条建议

00:05:40.903 --> 00:05:45.250
这里就是清理数据的函数

00:05:45.250 --> 00:05:47.290
其中使用了 possible_vals 中的值

00:05:47.290 --> 00:05:50.600
详细看一下代码

00:05:50.600 --> 00:05:54.070
其实就是遍历所有的建议

00:05:54.069 --> 00:05:56.944
画出对应的数量

00:05:56.944 --> 00:05:58.552
现在看上去好多了

00:05:58.552 --> 00:06:01.471
这是一个还不错的帮助函数

00:06:01.471 --> 00:06:05.740
接下来 有学位的人是否倾向于推荐别人获取学位?

00:06:05.740 --> 00:06:08.150
完成下面的函数

00:06:08.149 --> 00:06:10.974
该函数的参数是 df 中 FormalEducation 列的元素项

00:06:10.975 --> 00:06:13.885
需要传入 formal_ed_str

00:06:13.884 --> 00:06:17.589
也就是 FormalEducation 列中每个值 以字符串的形式

00:06:17.589 --> 00:06:23.507
如果输入的学历是这些中的一个则返回 1 否则返回 0

00:06:23.507 --> 00:06:33.474
也就是说 如果 formal_ed_str ……

00:06:33.475 --> 00:06:36.189
也就是说 如果 formal_ed_str ……

00:06:36.189 --> 00:06:38.439
直接复制粘贴

00:06:38.439 --> 00:06:42.404
如果在这个集合中 就返回 1

00:06:42.404 --> 00:06:50.934
否则返回 0

00:06:50.935 --> 00:06:55.720
然后将这个函数应用到 FormalEducation 列

00:06:55.720 --> 00:07:00.180
你可以看到 这里有一个人的学历属于硕士、博士或者专业学位

00:07:00.180 --> 00:07:02.115
你可以看到 这里有一个人的学历属于硕士、博士或者专业学位

00:07:02.115 --> 00:07:06.715
应该可以大致了解这个问题是想要做什么了

00:07:06.714 --> 00:07:09.269
就是查看某人是否拥有这些更高的学位

00:07:09.269 --> 00:07:12.714
如果是 那我们就想看看

00:07:12.714 --> 00:07:17.019
其是否更倾向于建议其他人也获取同样的学位

00:07:17.019 --> 00:07:19.524
换句话说 如果有人在没有这些学位的情况下

00:07:19.524 --> 00:07:22.377
进入技术领域 他们会感受到差异吗？

00:07:22.377 --> 00:07:24.474
你的学历是否会使你 更偏向于推动别人走上与你相同的道路

00:07:24.475 --> 00:07:28.305
你的学历是否会使你 更偏向于推动别人走上与你相同的道路

00:07:28.305 --> 00:07:31.360
这个 higher_ed 就是刚才那个函数

00:07:31.360 --> 00:07:34.944
我们应用该函数 然后获取均值

00:07:34.944 --> 00:07:36.730
如果你的函数写对了

00:07:36.730 --> 00:07:40.509
这里的测试结果就会告诉你

00:07:40.509 --> 00:07:46.173
这里显示 选择 df 中 HigherEd 等于 1 的数据

00:07:46.173 --> 00:07:56.241
就是用 HigherEd 筛选 df 的子集 是这样命名的

00:07:56.242 --> 00:07:58.045
对的 在前面的代码里

00:07:58.045 --> 00:08:03.086
我们创建了这个 HigherEd 列 然后在这里算出了其均值

00:08:03.086 --> 00:08:06.185
虽然没有显示出来 但是至少提示了这个答案是正确的

00:08:06.185 --> 00:08:12.214
如果想要的话 其实也可以把结果打印出来

00:08:12.214 --> 00:08:16.269
看上去 数据中 23% 的人拥有

00:08:16.269 --> 00:08:20.952
三个高等学历中的一个

00:08:20.952 --> 00:08:23.709
在这里 我们选择相应的数据子集

00:08:23.709 --> 00:08:28.719
ed_1 应该是 HigherEd 等于 1 的数据

00:08:28.720 --> 00:08:34.985
ed_0 应该是 HigherEd 等于 0 的数据

00:08:34.985 --> 00:08:41.465
再把结果打印出来 确保符合预期

00:08:41.465 --> 00:08:44.379
好的 前面的应该全都是 1

00:08:44.379 --> 00:08:47.799
我们就是打印出了 ed_1 的 5 条数据 如果都是 1

00:08:47.799 --> 00:08:51.794
那么就符合预期 因为筛选的就是 HigherEd 为 1 的数据子集

00:08:51.794 --> 00:08:53.439
然后第二个也全部都是 0

00:08:53.440 --> 00:08:55.880
如果得到的结果里 既有 1 又有 0

00:08:55.879 --> 00:08:59.195
那就与预期不符了

00:08:59.195 --> 00:09:01.399
我们继续

00:09:01.399 --> 00:09:04.169
这里有很多的代码 其实就是在绘制图表

00:09:04.169 --> 00:09:06.264
注释说 你可以查看这里的链接

00:09:06.264 --> 00:09:09.867
其可以告诉你绘制图表的一些技巧

00:09:09.868 --> 00:09:11.480
这里看上去真的很赞

00:09:11.480 --> 00:09:14.690
这个图表提供了有用的见解

00:09:14.690 --> 00:09:18.310
红色的柱形表示……

00:09:18.309 --> 00:09:23.132
柱形的大小展示了倾向差异程度

00:09:23.133 --> 00:09:24.660
针对两种人群

00:09:24.659 --> 00:09:28.894
那些有高等学历的人

00:09:28.894 --> 00:09:33.095
推荐网络课程的百分比为 20.5%

00:09:33.095 --> 00:09:36.185
而那些没有高等学历的人

00:09:36.184 --> 00:09:39.334
而那些没有高等学历的人

00:09:39.335 --> 00:09:42.920
则有 21% 的人推荐上网络课程

00:09:42.919 --> 00:09:47.235
也就说那些没有高学历的人更倾向于推荐网络课程

00:09:47.235 --> 00:09:51.730
这里还有一个差距非常明显的绿色柱形

00:09:51.730 --> 00:09:59.944
比其他所有的差距都要大 比如上面的 0.007 等

00:09:59.943 --> 00:10:02.068
比其他所有的差距都要大 比如上面的 0.007 等

00:10:02.068 --> 00:10:04.235
其他的差距都非常小

00:10:04.235 --> 00:10:07.544
但这一个则相差 2.5% 左右

00:10:07.544 --> 00:10:11.168
其他的甚至都没有到 1%

00:10:11.168 --> 00:10:14.600
这里的却达到了 2.5%

00:10:14.600 --> 00:10:16.894
可以看到这里对应的建议是硕士学位

00:10:16.894 --> 00:10:22.039
也就是说 那些学历高的人推荐

00:10:22.039 --> 00:10:27.307
继续读一个硕士学位 而在那些没有学位的人里面

00:10:27.307 --> 00:10:29.855
则只有 3% 的人推荐读硕士学位

00:10:29.855 --> 00:10:32.090
2.5% 的差距在所有建议的差距中是最大的

00:10:32.090 --> 00:10:35.450
2.5% 的差距在所有建议的差距中是最大的

00:10:35.450 --> 00:10:38.295
接下来的问题是 从上面的图表中 你能得出什么结论?

00:10:38.294 --> 00:10:41.424
看看这里

00:10:41.424 --> 00:10:43.109
如果我们运行这里的代码

00:10:43.110 --> 00:10:44.840
可以看到结果不对

00:10:44.840 --> 00:10:46.301
这里有好几个 False

00:10:46.301 --> 00:10:48.200
基本上就是要将正确的结论修改为 True

00:10:48.200 --> 00:10:51.470
每个人都应该有高学历

00:10:51.470 --> 00:10:55.160
我认为这个结论不太对

00:10:55.159 --> 00:10:59.089
每个人都应该选择最适合自己的路线 而不是只追求高学历

00:10:59.090 --> 00:11:04.629
网络课程是被推荐最多的学习方式 这个应该是对的

00:11:04.629 --> 00:11:08.794
这里之前改错了 应该是 False

00:11:08.794 --> 00:11:11.074
不管什么学历

00:11:11.075 --> 00:11:13.015
推荐网络课程的人数都是最多的

00:11:13.014 --> 00:11:16.220
是的 网络课程 两类群体的人都非常推荐

00:11:16.220 --> 00:11:19.779
是的 网络课程 两类群体的人都非常推荐

00:11:19.779 --> 00:11:22.579
两类人群对学习方式的推荐差距都小于 1%

00:11:22.580 --> 00:11:25.675
两类人群对学习方式的推荐差距都小于 1%

00:11:25.674 --> 00:11:28.654
这个不对 我们看到了这里有一个 2.5% 的差距

00:11:28.654 --> 00:11:32.903
这个不对 我们看到了这里有一个 2.5% 的差距

00:11:32.903 --> 00:11:34.769
有高学历的人 更倾向于推荐别人获取高学历

00:11:34.769 --> 00:11:37.490
有高学历的人 更倾向于推荐别人获取高学历

00:11:37.490 --> 00:11:41.384
这个是正确的

00:11:41.384 --> 00:11:43.669
赞 我们都答对了

00:11:43.669 --> 00:11:48.000
这个 Notebook 讲完了

