WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:01.679
在之前的课程中

00:00:01.679 --> 00:00:04.889
我提出了四个即将探索的问题

00:00:04.889 --> 00:00:08.684
先来浏览数据 看看如何回答第一个问题

00:00:08.685 --> 00:00:10.502
根据调查结果 如何入门 成为一名开发者

00:00:10.502 --> 00:00:13.230
根据调查结果 如何入门 成为一名开发者

00:00:13.230 --> 00:00:16.140
开始之前 先导入几个必要的库

00:00:16.140 --> 00:00:19.024
用于数据清理的 Pandas 和 NumPy

00:00:19.024 --> 00:00:21.570
如果我们想要绘制基础的图表

00:00:21.570 --> 00:00:23.594
那就需要用到 Matplotlib

00:00:23.594 --> 00:00:25.859
现在 来看一下第一个问题

00:00:25.859 --> 00:00:29.888
从业者对新手入门的建议是什么

00:00:30.088 --> 00:00:32.024
CousinEducation 这一列

00:00:32.024 --> 00:00:36.295
包含了调查参与者对其他人的帮助建议

00:00:36.295 --> 00:00:41.189
下面 你能看到所有参加调查问卷的人都能看到的完整字段

00:00:41.189 --> 00:00:44.054
我们看看问题选项有哪些

00:00:44.054 --> 00:00:46.978
这并不是我想要的效果

00:00:46.978 --> 00:00:48.548
如果参与者选择了一条以上的建议

00:00:48.548 --> 00:00:51.808
就会把所有选项都放在一起

00:00:51.810 --> 00:00:53.655
我们来看一下 是否能清理该数据

00:00:53.655 --> 00:00:58.219
首先 把 index 列名改成更合适的名称

00:00:58.219 --> 00:00:59.850
修改为 method (方法)

00:00:59.850 --> 00:01:02.403
在大概浏览完数据之后

00:01:02.603 --> 00:01:06.780
我们可以创建一个包含所有方法选项的列表

00:01:06.780 --> 00:01:09.113
其实也可以在调查问卷的文档中找到这些选项

00:01:09.313 --> 00:01:12.898
你也可以编写一个函数 输入每一行的文字

00:01:12.900 --> 00:01:18.150
用分号分割为不同的选项

00:01:18.150 --> 00:01:19.988
然后放入一个集合 (set) 中

00:01:20.188 --> 00:01:22.768
这样就不会有重复项了

00:01:22.769 --> 00:01:24.658
这里是我的选项列表

00:01:24.858 --> 00:01:28.938
现在 我们来看一下 列表中每一个选项的频数

00:01:28.938 --> 00:01:31.404
我写了一个函数来完成操作

00:01:31.405 --> 00:01:33.810
这并不是最好的解决方案 不过能够满足需求

00:01:33.810 --> 00:01:37.650
还好我们的数据量不大 不会占用太多计算资源

00:01:37.650 --> 00:01:39.393
现在我们可以应用该函数

00:01:39.593 --> 00:01:42.390
需要注意的是 函数里提供了一些文档字符串

00:01:42.390 --> 00:01:46.644
这样别人不用完全理解代码的逻辑 也可以正确使用该函数

00:01:46.644 --> 00:01:51.780
其向用户提供了输入和指定输出的说明

00:01:51.780 --> 00:01:54.105
这是非常重要的流程 不论是对未来的你

00:01:54.105 --> 00:01:57.436
还是对其他有合作机会的软件工程师

00:01:57.436 --> 00:01:59.158
在这里 我调用了该函数

00:01:59.358 --> 00:02:00.738
你可以看到

00:02:00.739 --> 00:02:02.768
我传入了前面定义过的 study DataFrame

00:02:02.968 --> 00:02:06.053
以及 method 和 count 这两个列名

00:02:06.055 --> 00:02:11.175
然后再传入 possible_vals 我之前创建的列表

00:02:11.175 --> 00:02:13.808
这是 study DataFrame 里的两个列名

00:02:14.008 --> 00:02:18.000
然后这个是我想要查找的选项列表

00:02:18.000 --> 00:02:20.443
现在 可以看到该函数返回的结果

00:02:20.443 --> 00:02:21.738
看上去对优达学诚是好消息

00:02:21.740 --> 00:02:25.058
大多数的人认为应该参加网络课程

00:02:25.258 --> 00:02:28.703
我们也可以把频数转换成百分比

00:02:28.705 --> 00:02:33.219
你可以看到 将近 21% 的人都建议参加网络课程

00:02:33.419 --> 00:02:35.899
比其他任何方法都要多

00:02:35.900 --> 00:02:38.550
我们还可以更进一步

00:02:38.550 --> 00:02:42.330
可能我们会更关心 收入高或者工作满意度较高的开发者给出的建议

00:02:42.330 --> 00:02:44.905
可能我们会更关心 收入高或者工作满意度较高的开发者给出的建议

00:02:44.905 --> 00:02:48.098
我们将这些因素纳入分析

00:02:48.098 --> 00:02:51.869
我更新了之前的函数 使其结果可以展现出

00:02:51.870 --> 00:02:56.594
这里每个方法与工资之间的联系

00:02:56.794 --> 00:02:59.699
在下一页的 Workspace 中可以找到该函数的代码

00:02:59.699 --> 00:03:03.364
你可以看到 这种情况下使用该函数会非常头疼

00:03:03.563 --> 00:03:05.638
其运行效率极低

00:03:05.639 --> 00:03:08.875
从计算的角度 我们需要一个更好的解决方案

00:03:08.875 --> 00:03:10.680
这一步运行完毕后

00:03:10.680 --> 00:03:12.938
我们想要按照 mean_col 来重新排序

00:03:12.938 --> 00:03:14.848
也就是说 具备最高平均收入的推荐方法排在最前面

00:03:14.848 --> 00:03:20.788
也就是说 具备最高平均收入的推荐方法排在最前面

00:03:20.788 --> 00:03:24.238
最终得到的结果应该是这样的

00:03:24.240 --> 00:03:28.460
这里是推荐这种方法的人数

00:03:28.460 --> 00:03:30.990
你可以发现这个排序跟我们之前看到的不一样

00:03:30.990 --> 00:03:33.868
因为不是所有的人都是有收入的

00:03:34.068 --> 00:03:37.163
他们并没有包含在数据中

00:03:37.163 --> 00:03:42.000
这里是推荐这种方法人的平均收入

00:03:42.000 --> 00:03:43.468
最后这几列

00:03:43.468 --> 00:03:47.685
还可以看到 收入均值的 95% 置信区间

00:03:47.685 --> 00:03:50.610
以及标准偏差和方差

00:03:50.610 --> 00:03:52.989
观察这些数值

00:03:53.188 --> 00:03:55.438
我们可以看看是否存在重叠

00:03:55.438 --> 00:03:58.543
如果没有的话 那就说明方法之间没有显著差异

00:03:58.544 --> 00:04:00.030
如果存在重叠

00:04:00.030 --> 00:04:05.030
则说明方法之间存在显著差异

