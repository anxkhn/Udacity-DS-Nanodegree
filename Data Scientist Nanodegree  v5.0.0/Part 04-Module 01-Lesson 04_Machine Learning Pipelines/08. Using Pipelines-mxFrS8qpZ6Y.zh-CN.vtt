WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.379
这有一个简单的例子

00:00:02.379 --> 00:00:07.224
我们使用 CountVectoriser 和 TfidfTransformer 从文本数据中生成特征

00:00:07.224 --> 00:00:13.085
然后将其提供给 RandomForestClassifier

00:00:13.085 --> 00:00:15.060
我们用这个来复习一些术语

00:00:15.060 --> 00:00:19.615
然后学习如何使用管道来简化这个过程

00:00:19.614 --> 00:00:23.539
这三个对象都属于评估器 (estimator)

00:00:23.539 --> 00:00:28.489
根据 scikit-learn 评估器是任何能够从数据中进行学习的对象

00:00:28.489 --> 00:00:30.364
无论它是一个

00:00:30.364 --> 00:00:33.100
分类的、回归的、聚类的算法

00:00:33.100 --> 00:00:38.795
或是从原始数据中提取或过滤有用信息的转换器 (transformer) 

00:00:38.795 --> 00:00:41.179
因为它从数据中学习

00:00:41.179 --> 00:00:45.500
每个评估器都必须有一个 fit (拟合) 方法 接收一个数据集

00:00:45.500 --> 00:00:49.744
所以 这三个评估器都有一个 fit 方法

00:00:49.744 --> 00:00:54.789
还有 CountVectoriser 和 TfidfTransformer

00:00:54.789 --> 00:00:58.969
以及一类专门的评估器叫做转换器 (transformer)

00:00:58.969 --> 00:01:01.789
意味着它有一个 transform (转换) 方法

00:01:01.789 --> 00:01:05.944
我们要介绍的最后一个评估器是预测器 (predictor)

00:01:05.944 --> 00:01:09.399
尽管预测器没有 transform 方法

00:01:09.400 --> 00:01:11.405
但是它有一个 predict 方法

00:01:11.405 --> 00:01:13.010
在机器学习任务中

00:01:13.010 --> 00:01:16.550
在经过最后一个评估器之前

00:01:16.549 --> 00:01:21.295
经常会通过某些转换器的序列先拟合数据

00:01:21.295 --> 00:01:25.365
一般情况下 我们必须将所有评估器初始化

00:01:25.364 --> 00:01:28.519
用每个转换器拟合数据 并转换训练数据

00:01:28.519 --> 00:01:32.908
然后用最后的评估器拟合数据

00:01:32.909 --> 00:01:38.255
接下来 我们必须再次调用转换器的 transform  转换测试数据

00:01:38.254 --> 00:01:43.519
最后调用最后一个评估器的 predict

00:01:43.519 --> 00:01:48.489
现在 如果我告诉你其实可以将所有这些拟合 转换和预测

00:01:48.489 --> 00:01:51.559
实现自动化

00:01:51.560 --> 00:01:56.394
只需把这些评估器串联成一个评估器对象

00:01:56.394 --> 00:02:00.869
这一个评估器就是 scikit-learn 管道

00:02:00.870 --> 00:02:02.650
要创建这个管道

00:02:02.650 --> 00:02:05.480
我们只需要一个键值对的列表

00:02:05.480 --> 00:02:09.140
其中 键是字符串 表示你想要命名的步骤

00:02:09.139 --> 00:02:13.464
值是评估器对象

00:02:13.465 --> 00:02:17.689
现在 通过管道拟合训练数据

00:02:17.689 --> 00:02:21.740
我们可以实现用多个对象逐个拟合和转换训练数据

00:02:21.740 --> 00:02:26.064
一样的效果

00:02:26.064 --> 00:02:31.129
类似的 当我们调用管道的 predict 方法来对测试数据进行预测时

00:02:31.129 --> 00:02:35.810
相当于每个转换器对象分别对测试数据调用 transform 方法

00:02:35.810 --> 00:02:42.020
然后对最后一个评估器调用 predict 方法

00:02:42.020 --> 00:02:46.000
不仅这种方法会让我们代码更加简洁

00:02:46.000 --> 00:02:51.169
另外的优点在下个视频中会提到

00:02:51.169 --> 00:02:55.924
注意 管道中的每个步骤都必须是一个转换器

00:02:55.925 --> 00:02:58.485
除了最后一步之外

00:02:58.485 --> 00:03:01.055
最后一步可以是任何类型的评估器

00:03:01.055 --> 00:03:06.900
管道的方法是由流程的最后一个评估器提供的

00:03:06.900 --> 00:03:12.689
例如 因为你的管道的最后一个评估器是分类器

00:03:12.689 --> 00:03:16.069
管道对象可以被当做分类器使用

00:03:16.069 --> 00:03:19.104
继承了 fit 和 predict 方法

00:03:19.104 --> 00:03:23.114
类似的 如果最后一个评估器是转换器

00:03:23.115 --> 00:03:28.730
管道对象可以当做转换器 你不能调用predict 方法

