WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.259
接着上个视频的示例

00:00:03.259 --> 00:00:05.339
假如你想要从同一列文本数据中

00:00:05.339 --> 00:00:09.599
提取两种特征

00:00:09.599 --> 00:00:13.744
"tf-idf" 值和文本的长度

00:00:13.744 --> 00:00:19.475
你的第一种方法可以是根据文本数据列新建一列

00:00:19.475 --> 00:00:21.615
叫做 'text_length' 像是这样

00:00:21.614 --> 00:00:27.524
然后 文本列 text 和 text_length 列都会出现在后续的矩阵中

00:00:27.524 --> 00:00:29.974
但是会导致你的管道不能正常工作

00:00:29.975 --> 00:00:34.814
你不能在字符串和数据组成的 NumPy 数组上运行 CountVectorizer

00:00:34.814 --> 00:00:40.804
现在 假设我们有一个自定义的转换器 TextLengthExtractor.

00:00:40.804 --> 00:00:43.820
这样的话 你可以保留 x_train

00:00:43.820 --> 00:00:46.909
作为原始的文本数据列

00:00:46.909 --> 00:00:50.784
只要你能找到办法将 TextLengthExtractor 加入到你的管道里即可

00:00:50.784 --> 00:00:56.114
只需使用 TextLengthExtractor 拟合原始的文本数据

00:00:56.115 --> 00:00:59.585
而不是拟合前一个转换器的输出数据

00:00:59.585 --> 00:01:03.799
但是同时需要 TfidfTransformer 的输出

00:01:03.799 --> 00:01:09.109
和TextLengthExtractor 的输出作为分类器的输入

00:01:09.109 --> 00:01:13.689
FeatureUnions 在应对这种需要时非常方便

00:01:13.689 --> 00:01:16.620
即在同一份数据上

00:01:16.620 --> 00:01:18.150
并行运行两个步骤

00:01:18.150 --> 00:01:21.515
并且将结果综合起来送入下一步的情况

00:01:21.515 --> 00:01:27.319
和管道一样 FeatureUnions 通过键值对的列表创建

00:01:27.319 --> 00:01:30.859
其中 键是字符串 是步骤的名称

00:01:30.859 --> 00:01:35.355
值是评估器对象

00:01:35.355 --> 00:01:39.124
类似地 FeatureUnion 将

00:01:39.123 --> 00:01:43.108
一列评估器组合成一个评估器

00:01:43.108 --> 00:01:47.039
不同的是 它的评估器是并行运行的

00:01:47.040 --> 00:01:50.120
而不是像管道一样串行执行

00:01:50.120 --> 00:01:57.385
在这个例子中 并行运行的两个评估器是 nlp_pipeline 和 text_length

00:01:57.385 --> 00:02:02.800
注意我们 FeatureUnion 中使用了管道以确保

00:02:02.799 --> 00:02:08.935
CountVectorizer 和 TfidfTransformer 两个步骤是串行执行的

00:02:08.935 --> 00:02:13.370
现在 我们的管道正常运行并且使用了两个特征

00:02:13.370 --> 00:02:17.409
这和这份代码的效果是一样的

00:02:17.409 --> 00:02:20.960
初始化所有的评估器后

00:02:20.960 --> 00:02:24.000
注意到 CountVectorizer 和

00:02:24.000 --> 00:02:30.270
TextLengthExtractor 的输入和转换都使用了原始的训练数据

00:02:30.270 --> 00:02:36.430
然后 它们的输出结合起来被传入分类器

00:02:36.430 --> 00:02:38.629
类似地 在测试数据上

00:02:38.629 --> 00:02:41.555
CountVectorizer 和 TextLengthExtractor

00:02:41.555 --> 00:02:44.460
都对原始的测试数据做了转换

00:02:44.460 --> 00:02:48.730
然后其结果被结合起来传入分类器

