WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.049
在开始创建推荐之前

00:00:03.049 --> 00:00:05.250
我们需要充分了解

00:00:05.250 --> 00:00:08.164
将在接下来的几节课中用到的数据

00:00:08.164 --> 00:00:12.309
在此 notebook 中 我们将探索数据并回答几个问题

00:00:12.310 --> 00:00:14.750
首先 我们将读取数据

00:00:14.750 --> 00:00:17.699
有两个数据集

00:00:17.699 --> 00:00:22.554
一个是 movies 数据集 它有三列

00:00:22.554 --> 00:00:25.039
一列是 movie_id 一列是 movie

00:00:25.039 --> 00:00:26.524
一列 genre

00:00:26.524 --> 00:00:32.475
genre 列有多个可能的类别 并且可能是 NaN

00:00:32.475 --> 00:00:35.590
再看看 reviews 数据集

00:00:35.899 --> 00:00:38.254
它有一个 user_id

00:00:38.255 --> 00:00:43.715
一个 movie_id 我猜测它与 movies 数据集的 movie_id 列相匹配

00:00:43.715 --> 00:00:48.035
一个 rating 表示用户对此电影的评分 还有一个 timestamp

00:00:48.034 --> 00:00:50.329
下面有几个问题

00:00:50.329 --> 00:00:53.089
其中一个是查找数据集中的电影数量

00:00:53.090 --> 00:00:58.960
输入 movies.shape[0]

00:00:58.960 --> 00:01:02.634
我这边显示有 31,917 部电影

00:01:02.634 --> 00:01:05.629
但是你的数据集可能数量不同

00:01:05.629 --> 00:01:08.839
取决于你是何时运行此 notebook 的

00:01:08.840 --> 00:01:16.540
我们实时地从不断更新的 MovieTweetings 数据集中提取数据

00:01:16.540 --> 00:01:21.910
评分数量可以通过 reviews.shapes[0] 获取

00:01:21.909 --> 00:01:28.674
评分数量很多

00:01:28.674 --> 00:01:31.219
不同风格的数量

00:01:31.219 --> 00:01:35.170
这个问题比较难

00:01:35.170 --> 00:01:39.439
再看看 movies 数据集

00:01:39.439 --> 00:01:46.704
我们要做的是能够从 genre 中提取这些部分

00:01:46.704 --> 00:01:49.734
我们可以编写一个小循环

00:01:49.734 --> 00:01:53.959
我将创建一个空的列表 叫做 genres

00:01:53.959 --> 00:01:57.769
然后遍历该列

00:01:57.769 --> 00:02:00.439
提取方法可能有很多种 这只是其中一种方法

00:02:00.439 --> 00:02:05.450
我将遍历此列并将这段代码放入 try-except 块中

00:02:05.450 --> 00:02:09.009
因为如果遇到 NaN

00:02:09.009 --> 00:02:13.114
则会出现属性错误

00:02:13.115 --> 00:02:16.340
如果遇到 NaN 则 pass

00:02:16.340 --> 00:02:20.560
否则提取数据

00:02:20.560 --> 00:02:25.560
我将拆分这部分

00:02:25.560 --> 00:02:28.020
看看代码的作用

00:02:28.020 --> 00:02:36.605
输入 movies.genre[0] 对其运行 split()

00:02:36.604 --> 00:02:40.579
系统将返回这些部分组成的列表

00:02:40.580 --> 00:02:42.290
我们可以

00:02:42.289 --> 00:02:45.754
遍历这些项目

00:02:45.754 --> 00:02:48.069
运行需要花点时间

00:02:48.069 --> 00:02:51.694
因为有 31,000 多个 但是不会太久

00:02:51.694 --> 00:02:56.319
我将遍历一遍并扩展此列表

00:02:56.319 --> 00:03:01.810
风格数量等于 len(set(genres))

00:03:02.629 --> 00:03:07.210
还可以获取这些风格的名称

00:03:10.189 --> 00:03:19.960
有 28 种 这些是所有的风格名称

00:03:21.500 --> 00:03:26.139
Yeah有 28 种 这些是名称列表

00:03:26.139 --> 00:03:29.119
重申下 可能有更好的实现方式

00:03:29.120 --> 00:03:31.920
这只是其中一种可行的方式

00:03:31.919 --> 00:03:34.269
我只是遍历所有的可能性

00:03:34.270 --> 00:03:36.895
拆分项目 创建列表

00:03:36.895 --> 00:03:39.740
然后扩展原始列表

00:03:39.740 --> 00:03:43.180
最后使用 set() 获取唯一项

00:03:43.180 --> 00:03:51.730
下个问题是获取唯一用户数量

00:03:51.729 --> 00:03:58.465
输入 np.unique 对 reviews 数据集运行该方法

00:03:58.465 --> 00:04:01.409
这是第一个用户

00:04:08.860 --> 00:04:10.940
用户 ID

00:04:10.939 --> 00:04:20.250
Ok在我的数据集中

00:04:20.250 --> 00:04:28.649
有 54,000 个唯一用户

00:04:28.649 --> 00:04:32.104
下个问题是 reviews 数据集中缺少的评分数量

00:04:32.105 --> 00:04:38.105
输入 reviews.rating

00:04:38.105 --> 00:04:42.250
Great然后输入 isnull().sum()

00:04:42.250 --> 00:04:47.540
看起来没有缺少任何评分

00:04:47.540 --> 00:04:54.905
平均评分为 7.3 分

00:04:54.904 --> 00:05:00.004
实际上可以查看很多统计数据

00:05:00.004 --> 00:05:03.334
最低分为 0 分

00:05:03.334 --> 00:05:06.139
最高分为 10 分

00:05:06.139 --> 00:05:09.439
还有很多其他有用的信息

00:05:09.439 --> 00:05:14.040
例如均值 第 25 百分位 第 75 百分位

