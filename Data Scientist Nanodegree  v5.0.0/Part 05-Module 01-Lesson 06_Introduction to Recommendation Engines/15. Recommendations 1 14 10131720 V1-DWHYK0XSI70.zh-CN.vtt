WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:01.620
第三种相似性衡量方法是

00:00:01.620 --> 00:00:04.150
Kendall's tau 相关系数

00:00:04.150 --> 00:00:08.510
同样使用了排名数据 但是这里有个 sign

00:00:08.509 --> 00:00:11.184
sign 为正或为负

00:00:11.185 --> 00:00:12.600
这个公式表示

00:00:12.599 --> 00:00:14.789
如果两项都为正

00:00:14.789 --> 00:00:17.890
那么这个将为 1

00:00:17.890 --> 00:00:21.144
如果两个都为负

00:00:21.144 --> 00:00:22.829
那么这个依然是 1

00:00:22.829 --> 00:00:26.419
如果两项的方向相反

00:00:26.420 --> 00:00:29.560
那么就好像与 Kendall's tau 对立

00:00:29.559 --> 00:00:33.329
x 和 y 的移动方式相互关联

00:00:33.329 --> 00:00:35.280
如果都为正或都为负

00:00:35.280 --> 00:00:37.965
则朝着相同的方向移动 它们更相似

00:00:37.965 --> 00:00:40.640
如果一个为正 另一个为负

00:00:40.640 --> 00:00:42.770
则朝着不同的方向移动

00:00:42.770 --> 00:00:45.734
所以二者关系不太相似

00:00:45.734 --> 00:00:48.880
这就是 Kendall's tau 相关系数的含义

00:00:48.880 --> 00:00:50.750
我们来看看计算方法

00:00:50.750 --> 00:00:53.079
再看看这些变量

00:00:53.079 --> 00:00:55.219
n 表示长度

00:00:55.219 --> 00:00:58.600
同样使用已排名版本

00:00:58.600 --> 00:01:00.750
像这样

00:01:07.810 --> 00:01:11.695
提取已排名版本

00:01:11.694 --> 00:01:15.625
还需要这部分

00:01:15.625 --> 00:01:18.129
n 等于长度

00:01:18.129 --> 00:01:19.579
x 和 y 应该长度相同

00:01:19.579 --> 00:01:22.929
所以用谁的长度都一样

00:01:22.930 --> 00:01:25.370
接下来

00:01:25.370 --> 00:01:27.689
我将跟踪这个顺序

00:01:27.689 --> 00:01:29.864
如果 i 大于 j

00:01:29.864 --> 00:01:33.089
那么我们将计算这些差值

00:01:33.090 --> 00:01:35.579
如果 i 不大于 j 则不求和

00:01:35.579 --> 00:01:38.120
这里有点难

00:01:38.120 --> 00:01:40.020
我将创建 sum_vals

00:01:40.019 --> 00:01:46.609
用于跟踪所有的和

00:01:46.609 --> 00:01:51.659
我将同时遍历 x 值和 y 值

00:01:51.659 --> 00:01:53.810
查看它们的索引

00:01:53.810 --> 00:01:59.150
通过 enumerate() 可以轻松地查看索引

00:01:59.150 --> 00:02:03.000
使用 zip() 可以将 x 和 y 放到一起

00:02:03.000 --> 00:02:06.319
这部分将它们 zip 到一起

00:02:06.319 --> 00:02:10.489
将这两个向量组合到一起

00:02:10.490 --> 00:02:15.520
然后 enumerate() 将提取我们所在的索引

00:02:15.520 --> 00:02:20.719
然后执行相同的步骤

00:02:20.719 --> 00:02:26.659
这个 i 与这个 i 一样

00:02:26.659 --> 00:02:30.759
这个 j 与这个 j 一样

00:02:30.759 --> 00:02:34.454
我们查看的是第 i 次迭代

00:02:34.455 --> 00:02:36.275
减去第 j 次迭代

00:02:36.275 --> 00:02:38.735
前提是 i 小于 j

00:02:38.735 --> 00:02:40.670
这就是我们要跟踪的内容

00:02:40.669 --> 00:02:42.484
这是 i 和 j

00:02:42.485 --> 00:02:44.800
这是 yi 和 yj

00:02:44.800 --> 00:02:49.475
将这里改成 j 和 j

00:02:49.474 --> 00:02:54.229
现在我的代码语法与数学公式保持一致了

00:02:54.229 --> 00:02:55.715
原理是

00:02:55.715 --> 00:02:58.370
如果 i 小于 j

00:02:58.370 --> 00:03:03.379
则与 sum_vals 相加

00:03:03.379 --> 00:03:10.704
NumPy 中有一个很方便的函数可以完成此操作 叫做 np.sign

00:03:10.705 --> 00:03:13.395
在这里使用 np.sign 函数

00:03:13.395 --> 00:03:17.165
对这两项求差值 然后相加

00:03:17.164 --> 00:03:20.120
x_i - x_j

00:03:20.120 --> 00:03:26.700
输入 x_i - x_j

00:03:26.699 --> 00:03:35.114
乘以 sign(y_i - y_j)

00:03:35.115 --> 00:03:39.870
y_i - y_j

00:03:39.870 --> 00:03:42.180
这里应该是减号

00:03:42.180 --> 00:03:44.655
将它们相乘

00:03:44.655 --> 00:03:46.365
得出 sum_vals

00:03:46.365 --> 00:03:47.700
对所有这些求和后

00:03:47.699 --> 00:03:49.544
再完成这部分

00:03:49.544 --> 00:03:54.839
最后完成这一部分

00:03:54.840 --> 00:03:58.580
使这里算出的 sum_vals 乘以 2

00:03:58.580 --> 00:04:01.725
然后除以 n(n-1)

00:04:01.724 --> 00:04:04.400
sum_vals 乘以 2

00:04:04.400 --> 00:04:09.585
然后除以 n(n-1)

00:04:09.585 --> 00:04:12.090
看来通过了所有测试

00:04:12.090 --> 00:04:17.000
下面根据此函数回答这些问题

00:04:17.000 --> 00:04:19.069
对于 play_data 的所有列

00:04:19.069 --> 00:04:24.079
斯皮尔曼系数和 Kendall's tau 系数匹配吗？然后是斯皮尔曼系数与皮尔逊系数

00:04:24.079 --> 00:04:25.459
还有皮尔逊系数与 Kendall 系数

00:04:25.459 --> 00:04:28.004
由你来回答这些问题吧

00:04:28.004 --> 00:04:32.370
Ok接下来我们将学习不同的距离函数

00:04:32.370 --> 00:04:34.850
这些方法很好计算

00:04:34.850 --> 00:04:37.100
尤其是刚刚已经介绍了三个相关系数的计算方法

00:04:37.100 --> 00:04:41.480
所以由你自己来完成吧

