WEBVTT
Kind: captions
Language: zh-CN

00:00:13.070 --> 00:00:16.875
为何依然会出现 NaN？

00:00:16.875 --> 00:00:19.890
我们来看看标题

00:00:19.890 --> 00:00:23.489
当我们比较用户 2 和用户 104 时

00:00:23.489 --> 00:00:25.390
也就是这里测试的用户对

00:00:25.390 --> 00:00:28.469
我们获得了 NaN 值 不应该出现 NaN 值的

00:00:28.469 --> 00:00:31.814
因为我们只是比较匹配的用户对

00:00:31.815 --> 00:00:33.660
所以不应该出现 NaN

00:00:33.659 --> 00:00:37.243
下面回忆下之前的相关系数

00:00:37.243 --> 00:00:39.539
回想下它的计算流程

00:00:39.539 --> 00:00:40.945
因为我们在这里使用了该相关系数

00:00:40.945 --> 00:00:44.494
你可能会明白为何出现 NaN

00:00:44.494 --> 00:00:51.109
我们来看看 movies_to_analyze[2]

00:00:51.109 --> 00:00:56.219
和 movies_to_analyze[104]

00:00:56.219 --> 00:00:59.344
也就是在这里

00:00:59.344 --> 00:01:01.159
出现 NaN 的用户对比较

00:01:01.159 --> 00:01:03.754
对它们运行 set()

00:01:03.755 --> 00:01:07.234
这样仅获得唯一值

00:01:07.234 --> 00:01:13.310
将这个称为 set_2 并将这个称为 set_104

00:01:13.310 --> 00:01:19.260
快速输出结果

00:01:21.530 --> 00:01:26.189
name ‘movies_to_analyze’ is not defined

00:01:26.189 --> 00:01:30.170
哦 这里拼错了 应该是 analyze

00:01:30.170 --> 00:01:32.635
大家可能已经注意到这个拼写错误

00:01:32.635 --> 00:01:34.240
这些是

00:01:34.239 --> 00:01:37.619
用户 104 看过的电影

00:01:37.620 --> 00:01:43.750
如果运行 intersection(set_2)

00:01:46.400 --> 00:01:49.335
将返回他们都看过的电影

00:01:49.334 --> 00:01:51.989
他们都看过相同的电影时

00:01:51.989 --> 00:01:56.379
这里却出现了 NaN

00:01:56.379 --> 00:01:58.074
我们从相关系数的角度思考为何会这样

00:01:58.075 --> 00:02:01.359
想一想相关系数的计算方式

00:02:01.359 --> 00:02:05.629
相关系数会查看这些观察值的比较情况

00:02:05.629 --> 00:02:07.909
看看它们的均值

00:02:07.909 --> 00:02:09.514
在分母中计算标准差

00:02:09.514 --> 00:02:12.139
出现 NaN 的原因之一是

00:02:12.139 --> 00:02:14.089
其中一个标准差为 0

00:02:14.090 --> 00:02:18.134
除以 0 的话 会出现 NaN

00:02:18.134 --> 00:02:20.129
我们不能除以 0

00:02:20.129 --> 00:02:25.039
我们可以查看

00:02:25.039 --> 00:02:30.169
每位用户对这些电影的具体评分

00:02:30.169 --> 00:02:33.089
将结果存储到变量中

00:02:33.340 --> 00:02:38.460
变量名暂时设为 same_movs

00:02:40.060 --> 00:02:42.680
可以看到 对于用户 2

00:02:42.680 --> 00:02:45.080
所有评分都一样

00:02:45.080 --> 00:02:47.105
所以标准差为 0

00:02:47.104 --> 00:02:49.369
当我们计算相关系数时

00:02:49.370 --> 00:02:51.259
分母中出现了 0

00:02:51.259 --> 00:02:54.804
这很糟糕 我们将获得 NaN

00:02:54.805 --> 00:02:58.159
这里不应该使用相似性指标

00:02:58.158 --> 00:03:00.949
而是使用欧几里得距离等其他指标

00:03:00.949 --> 00:03:05.044
这样就不会出现 NaN

00:03:05.044 --> 00:03:07.669
与之前

00:03:07.669 --> 00:03:09.500
计算相关系数差不多

00:03:09.500 --> 00:03:12.349
我们可以使用这里的大部分代码

00:03:12.349 --> 00:03:17.039
我直接将这些代码复制到下面

00:03:17.539 --> 00:03:20.750
我们将计算欧几里得距离

00:03:20.750 --> 00:03:25.039
而不是相关系数

00:03:25.039 --> 00:03:26.854
在 Google 中快速搜索后

00:03:26.854 --> 00:03:31.489
我找到了这个很方便的 NumPy 方法

00:03:31.490 --> 00:03:36.950
我们将使用 linalg.norm()

00:03:36.949 --> 00:03:41.149
计算范数和计算

00:03:41.149 --> 00:03:43.759
两个事物之间的欧几里得距离是一样的

00:03:43.759 --> 00:03:48.590
所以计算相关列的范数

00:03:48.590 --> 00:03:52.319
在这里实际上是与用户 1 相关的行

00:03:52.319 --> 00:03:54.109
获取与用户 2 相关的行

00:03:54.110 --> 00:03:55.910
获取这两个向量之间的差异

00:03:55.909 --> 00:03:57.889
然后计算范数

00:03:57.889 --> 00:04:01.198
实际上就是计算欧几里得距离

