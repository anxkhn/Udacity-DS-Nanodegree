WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.609
函数已经运行完毕

00:00:04.400 --> 00:00:07.065
看起来

00:00:07.065 --> 00:00:11.295
我们需要做出和之前差不多的更改

00:00:11.294 --> 00:00:14.504
改成这样

00:00:14.505 --> 00:00:17.280
删掉这部分

00:00:17.280 --> 00:00:23.100
这个改成 pd.read_pickle

00:00:23.100 --> 00:00:25.905
好的抱歉 我没有将有趣的部分添加进来

00:00:25.905 --> 00:00:27.630
到目前为止

00:00:27.629 --> 00:00:30.524
我们已经实现了协同过滤

00:00:30.524 --> 00:00:34.454
我们来看看 all_recs

00:00:34.454 --> 00:00:39.765
all_recs_sol.head()我知道了

00:00:39.765 --> 00:00:41.744
all_recs 是一个字典

00:00:41.744 --> 00:00:48.299
all_recs 和 all_recs_sol 是字典

00:00:48.299 --> 00:00:49.739
我们来看看这个结果

00:00:49.740 --> 00:00:53.780
这些是向用户 2 推荐的电影

00:00:53.780 --> 00:00:55.435
再看看用户 8

00:00:55.435 --> 00:00:56.850
是的这是用户 8 的结果

00:00:56.850 --> 00:00:58.820
这些是向用户 8 推荐的电影

00:00:58.820 --> 00:01:00.619
下面还有很多电影

00:01:00.619 --> 00:01:04.250
原因可能是第一次与该用户

00:01:04.250 --> 00:01:08.754
紧密匹配的用户观看了很多电影

00:01:08.754 --> 00:01:10.530
原因可能是这个

00:01:10.530 --> 00:01:12.480
Great最后

00:01:12.480 --> 00:01:16.640
我们来回答几个问题 检验下你的理解情况

00:01:16.640 --> 00:01:20.930
你刚刚实现的推荐系统

00:01:20.930 --> 00:01:23.120
称为协同过滤

00:01:23.120 --> 00:01:27.079
它是一个基于用户的协同过滤 因为我们是在相互比较用户

00:01:27.079 --> 00:01:30.515
我们衡量相似性时用到的两个方法是

00:01:30.515 --> 00:01:37.969
皮尔逊相关系数和欧几里得距离

00:01:37.969 --> 00:01:41.209
所以答案是 e

00:01:41.209 --> 00:01:44.239
使用相关系数有个问题 是什么问题？

00:01:44.239 --> 00:01:46.099
问题是我们除以 0

00:01:46.099 --> 00:01:49.164
因为某些评分的标准差为 0

00:01:49.165 --> 00:01:53.900
所以答案是 h

00:01:53.900 --> 00:01:56.090
请在以下单元格中使用这三个对象正确填写以下字典

00:01:56.090 --> 00:01:57.710
有多少对用户...

00:01:57.709 --> 00:02:01.824
这些问题是为了检验你是否会使用你创建的每个对象

00:02:01.825 --> 00:02:05.210
我们能查找没有获得任何推荐的用户吗？

00:02:05.209 --> 00:02:09.694
我们可以编写一个循环

00:02:09.694 --> 00:02:13.099
我将创建一个暂时为空的列表

00:02:13.099 --> 00:02:23.400
for user, movie_recs in all_recs.items()

00:02:23.400 --> 00:02:25.879
这是一个字典 键是用户

00:02:25.879 --> 00:02:28.835
movie_recs 是推荐电影

00:02:28.835 --> 00:02:31.439
如果列表长度为零

00:02:31.439 --> 00:02:33.669
我们将...

00:02:34.879 --> 00:02:37.544
如果列表里什么也没有

00:02:37.544 --> 00:02:46.244
我们将 users 附加到 users_without_recs

00:02:46.245 --> 00:02:53.210
Great然后查看 users_without_recs 的长度

00:02:53.210 --> 00:02:56.960
长度为 1319

00:02:56.960 --> 00:03:00.135
有多少 NaN 系数值？

00:03:00.134 --> 00:03:03.530
我们可以使用 df_corrs 得出这个值

00:03:03.530 --> 00:03:06.460
我们要查找有哪些列的

00:03:06.460 --> 00:03:11.640
电影相关系数为 Null 值

00:03:14.349 --> 00:03:19.229
结果有 200 多万

00:03:19.229 --> 00:03:22.329
看看这部分代码

00:03:22.330 --> 00:03:25.719
我们将查看该 df_corrs 中

00:03:25.718 --> 00:03:30.194
有多少相关系数为 Null

00:03:30.194 --> 00:03:32.180
这个的结果为 true 或 false

00:03:32.180 --> 00:03:36.080
如果调用 sum() 的话 将返回 true 的数量

00:03:36.080 --> 00:03:38.825
欧几里得距离也一样

00:03:38.824 --> 00:03:46.369
对应的是 df_dists 列名为 eucl_dist

00:03:46.370 --> 00:03:48.379
这个也是一列

00:03:48.379 --> 00:03:52.694
同样 调用 isnull() 然后调用 sum()

00:03:52.694 --> 00:03:56.840
结果应该为 0这部分比较重要

00:03:56.840 --> 00:03:58.150
当我们使用相关系数时

00:03:58.150 --> 00:04:00.955
有很多时候我们除以了 0

00:04:00.955 --> 00:04:03.200
这是因为特定用户的

00:04:03.199 --> 00:04:06.099
某个近邻的评分标准差为 0

00:04:06.099 --> 00:04:10.759
但是如果使用传统距离指标 例如欧几里得距离

00:04:10.759 --> 00:04:12.274
而不是相似性指标

00:04:12.275 --> 00:04:14.974
就不会出现这些问题

00:04:14.974 --> 00:04:16.534
与这里相似

00:04:16.535 --> 00:04:19.640
我们也可以查找评分数量少于 10 条的用户

00:04:19.639 --> 00:04:27.300
复制这段代码 改成 users_lt10_recs

00:04:27.649 --> 00:04:30.674
这里也是 users_lt10_recs

00:04:30.675 --> 00:04:32.520
这里应该改成

00:04:32.519 --> 00:04:42.750
如果长度小于 10

00:04:42.750 --> 00:04:45.399
结果是 1325

