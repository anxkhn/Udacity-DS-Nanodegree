WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.990
下一步我们将创建该矩阵

00:00:03.990 --> 00:00:07.785
并返回矩阵这是最终目标

00:00:07.785 --> 00:00:10.470
我们将创建一个字典 movies_seen

00:00:10.470 --> 00:00:13.589
键是用户

00:00:13.589 --> 00:00:17.969
值是电影 ID 列表或数组

00:00:17.969 --> 00:00:19.739
它可以是一个列表或 NumPy 数组

00:00:19.739 --> 00:00:22.049
还可以是一个集合

00:00:22.050 --> 00:00:24.960
建议创建一个辅助函数

00:00:24.960 --> 00:00:27.420
它可以获取

00:00:27.420 --> 00:00:30.540
任何给定 ID 对应的已看过电影

00:00:30.539 --> 00:00:33.839
我喜欢提取出数据

00:00:33.840 --> 00:00:37.170
看看有哪些数据 并查看一个示例

00:00:37.170 --> 00:00:40.130
看看该函数的标题

00:00:40.130 --> 00:00:43.275
这是一个很稀疏的矩阵

00:00:43.274 --> 00:00:46.879
到处都是 NaN

00:00:46.880 --> 00:00:51.200
如果我们提取出用户 1 或用户 2 的数据

00:00:51.200 --> 00:00:54.260
它会返回一个包含所有电影的数组

00:00:54.259 --> 00:00:56.225
每行都是 ID

00:00:56.225 --> 00:00:57.965
每列都是电影

00:00:57.965 --> 00:01:02.150
这是用户 2 对所有电影的评分

00:01:02.149 --> 00:01:05.120
几乎都是 NaN

00:01:05.120 --> 00:01:06.995
他们还没有对很多电影评分

00:01:06.995 --> 00:01:10.189
如果要提取

00:01:10.189 --> 00:01:12.319
用户看过的所有电影

00:01:12.319 --> 00:01:16.984
我们需要看看哪些为 null 哪些不是

00:01:16.984 --> 00:01:19.129
对于这部分

00:01:19.129 --> 00:01:22.594
这个 isnull() 会返回一个 true/false 数组

00:01:22.594 --> 00:01:25.200
如果返回 true

00:01:25.200 --> 00:01:28.189
则表明这里是 null 值 否则不是

00:01:28.189 --> 00:01:33.500
如果返回 false

00:01:33.500 --> 00:01:39.394
那么提取该用户的 user_by_movie 值

00:01:39.394 --> 00:01:45.399
代码是这样的

00:01:45.799 --> 00:01:49.325
它的作用是

00:01:49.325 --> 00:01:52.234
返回这些电影的索引并返回这些值

00:01:52.234 --> 00:01:56.879
结果是这样的数组 不错

00:02:00.980 --> 00:02:04.770
将这里的 2

00:02:04.769 --> 00:02:08.430
替换成传入的 user_id

00:02:08.430 --> 00:02:11.110
提供用户 ID 后

00:02:11.110 --> 00:02:13.190
我们将查看此用户评过分的电影

00:02:13.189 --> 00:02:15.740
然后将返回结果存储到这个 movie 变量中

00:02:15.740 --> 00:02:17.020
并返回结果

00:02:17.020 --> 00:02:19.375
下一部分的目标是

00:02:19.375 --> 00:02:21.830
遍历这个函数

00:02:21.830 --> 00:02:27.020
获取一个叫做 movies_seen 的字典

00:02:27.020 --> 00:02:31.594
值是这个数组 键是用户

00:02:31.594 --> 00:02:34.729
这里运行时间较长

00:02:34.729 --> 00:02:37.039
我设置了一个进度条

00:02:37.039 --> 00:02:41.044
而你只需创建该字典

00:02:41.044 --> 00:02:45.269
我们的主要任务是创建字典

00:02:45.319 --> 00:02:47.939
将结果存储到此变量中

00:02:47.939 --> 00:02:50.919
我还创建了 n_users

00:02:50.919 --> 00:02:54.919
它等于行数

00:02:54.919 --> 00:02:59.434
表示数据集中的用户数量

00:02:59.435 --> 00:03:05.465
我将使用它创建循环

00:03:05.465 --> 00:03:14.340
for user1 in range(1:n_users+1);

00:03:14.870 --> 00:03:17.250
我们将使用

00:03:17.250 --> 00:03:24.269
movies_seen 作为字典

00:03:24.269 --> 00:03:25.500
我将传入 user1

00:03:25.500 --> 00:03:33.159
使其等于 movies_watched(user1)

00:03:33.159 --> 00:03:35.389
你只需完成这些步骤

00:03:35.389 --> 00:03:37.549
如果你查看解答 notebook

00:03:37.550 --> 00:03:40.580
会发现我添加了一个进度条 目的是看看代码运行情况

00:03:40.580 --> 00:03:42.770
我多次使用了进度条

00:03:42.770 --> 00:03:52.689
哦 这里出错了

00:03:57.949 --> 00:04:00.939
如果你设置正确的话

00:04:00.939 --> 00:04:03.379
应该会在这里看到进度条

00:04:03.379 --> 00:04:05.509
当系统遍历每个用户并计算时

00:04:05.509 --> 00:04:07.939
这里会出现百分比

00:04:07.939 --> 00:04:11.650
这部分的运行时间很长

00:04:21.769 --> 00:04:26.419
需要注意的是

00:04:26.420 --> 00:04:28.415
这里使用 loc 还是 iloc

00:04:28.415 --> 00:04:31.175
如果使用 iloc 这里要改一下

00:04:31.175 --> 00:04:32.735
我的代码因为这个错误而崩溃了

00:04:32.735 --> 00:04:35.520
我将重新运行代码

00:04:40.100 --> 00:04:42.590
运行此单元格后

00:04:42.589 --> 00:04:47.029
我们现在获得了存储字典的 movies_seen

00:04:47.029 --> 00:04:53.109
该字典的键是用户 ID 值是数组

