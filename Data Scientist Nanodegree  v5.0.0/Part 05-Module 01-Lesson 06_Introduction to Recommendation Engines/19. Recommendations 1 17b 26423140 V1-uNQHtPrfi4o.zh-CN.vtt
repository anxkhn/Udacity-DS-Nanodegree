WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:05.160
这部分的逻辑比较复杂

00:00:05.160 --> 00:00:07.589
我们将根据在上面编写的函数

00:00:07.589 --> 00:00:10.259
向用户推荐电影

00:00:10.259 --> 00:00:12.629
下面说说我的实现步骤

00:00:12.630 --> 00:00:15.825
当然 你可以用多种不同的方式编写这些代码

00:00:15.824 --> 00:00:19.559
我为每个用户创建了这个 movie_seen

00:00:19.559 --> 00:00:24.524
并跟踪用户看过了哪些电影

00:00:24.524 --> 00:00:27.209
movie_seen 存储了用户看过的所有电影

00:00:27.210 --> 00:00:29.070
这很重要

00:00:29.070 --> 00:00:31.980
因为我们不希望向该用户推荐这些电影

00:00:31.980 --> 00:00:35.594
我还创建了 closest_neighbors

00:00:35.594 --> 00:00:38.729
它返回的是与这个用户最近邻的

00:00:38.729 --> 00:00:44.134
用户 ID 的有序列表

00:00:44.134 --> 00:00:45.710
如果你传入一个用户

00:00:45.710 --> 00:00:47.329
我将查找该用户看过的电影

00:00:47.329 --> 00:00:49.179
并找到他的最近邻

00:00:49.179 --> 00:00:51.810
接着 我创建了这个 recs()

00:00:51.810 --> 00:00:54.890
它是一个空的 NumPy 数组

00:00:54.890 --> 00:00:56.929
我会向里面添加多项内容

00:00:56.929 --> 00:00:58.640
对于 closest_neighbors 中的

00:00:58.640 --> 00:01:03.179
每个近邻

00:01:03.179 --> 00:01:06.995
我将获取该近邻喜欢的电影

00:01:06.995 --> 00:01:09.260
我将使用刚刚编写的函数

00:01:09.260 --> 00:01:12.155
查找该近邻喜欢的电影

00:01:12.155 --> 00:01:14.430
在这里输入

00:01:14.769 --> 00:01:23.149
neigh_likes = movies_liked(neighbor)

00:01:23.150 --> 00:01:26.265
Ok这是近邻的 ID

00:01:26.265 --> 00:01:29.579
传入该 ID 并获取近邻喜欢的电影

00:01:29.579 --> 00:01:34.310
有一个方法很方便

00:01:34.310 --> 00:01:39.125
它可以比较两个 NumPy 数组 并返回在一个数组中但不在另一个里面的值

00:01:39.125 --> 00:01:42.180
这个方法称为 np.setdiff1d()

00:01:43.719 --> 00:01:47.750
它会获取第一个数组

00:01:47.750 --> 00:01:50.950
我称为 neigh_ likes

00:01:50.950 --> 00:01:55.799
然后查看第二个数组 即 movies_ seen

00:01:55.799 --> 00:02:00.609
在这里使用 assume_unique = true 使代码更快

00:02:00.609 --> 00:02:04.120
与之前使用的intersection() 函数相似

00:02:04.120 --> 00:02:06.350
这个函数将查看两个数组之间的差异

00:02:06.349 --> 00:02:08.900
并返回一个新的数组

00:02:08.900 --> 00:02:12.170
其中包含在这个数组里

00:02:12.169 --> 00:02:15.244
但不在这个数组里的所有电影

00:02:15.245 --> 00:02:19.640
它将提取该用户喜欢的而此用户尚未看过的电影

00:02:19.639 --> 00:02:24.904
我们将其设为等于 new_recs

00:02:24.905 --> 00:02:28.395
然后将 new_recs

00:02:28.395 --> 00:02:33.000
与原始 recs 相连并作为推荐内容

00:02:33.000 --> 00:02:38.580
我们将获取唯一值

00:02:41.680 --> 00:02:45.230
这行代码的作用是将这两个数组连接到一起

00:02:45.229 --> 00:02:48.379
然后仅返回唯一值

00:02:48.379 --> 00:02:52.159
连接新推荐数组和旧推荐数组

00:02:52.159 --> 00:02:54.530
旧推荐数组本来里面什么也没有

00:02:54.530 --> 00:02:57.784
但是当我们为每个近邻不断连接新的推荐内容时

00:02:57.784 --> 00:03:01.770
它将存储越来越多的内容

00:03:01.770 --> 00:03:06.480
然后查看这个 recs 数组的长度

00:03:06.479 --> 00:03:11.000
如果已经达到推荐数量上限

00:03:11.000 --> 00:03:13.775
则停止连接并返回这些推荐电影

00:03:13.775 --> 00:03:20.885
如果 recs 的长度大于 num_recs

00:03:20.884 --> 00:03:24.629
这里是 num_recs -1 则 break

00:03:24.629 --> 00:03:29.629
recommendations 将等于 movie_names()

00:03:29.629 --> 00:03:33.079
这就是我们在上面创建这个函数的原因 然后传入recs

00:03:33.080 --> 00:03:37.080
这个 recs 将是所有的 ID

00:03:37.080 --> 00:03:39.680
而我们想在这个 recommendations 部分

00:03:39.680 --> 00:03:42.754
获取的是片名

00:03:42.754 --> 00:03:44.909
也就是这部分的作用

