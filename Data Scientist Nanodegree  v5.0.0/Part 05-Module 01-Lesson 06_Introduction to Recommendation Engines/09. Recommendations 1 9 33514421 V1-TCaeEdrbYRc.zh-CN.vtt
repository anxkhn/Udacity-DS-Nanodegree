WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:01.610
在最后一部分

00:00:01.610 --> 00:00:03.305
我们将添加过滤器

00:00:03.305 --> 00:00:05.455
对于这个函数

00:00:05.455 --> 00:00:09.929
它将返回最热门的推荐内容 无论是什么内容

00:00:09.929 --> 00:00:15.835
我们可以从这个 ranked_movies DataFrame 中了解一些信息

00:00:15.835 --> 00:00:17.960
我们创建了该 DataFrame 现在可以使用它

00:00:17.960 --> 00:00:20.679
看看这个 DataFrame

00:00:20.679 --> 00:00:26.939
我们可以从这个表格中选择特定的年份或类型

00:00:26.940 --> 00:00:33.140
并提取出特定年份或类型的电影

00:00:33.140 --> 00:00:36.359
它们有相关的日期

00:00:36.359 --> 00:00:37.519
可以检查该日期

00:00:37.520 --> 00:00:44.245
或者检查这些是 1 还是 0 甚至可以提取出类型部分

00:00:44.244 --> 00:00:48.019
如果这里显示了特定的文本

00:00:48.020 --> 00:00:51.195
我们可以仅返回这种类型的电影

00:00:51.195 --> 00:00:55.820
如果想要创建实现这种操作的函数

00:00:55.820 --> 00:00:57.075
可以称之为...至少我是这么命名的

00:00:57.075 --> 00:01:01.484
从这里的文本可以看出 叫做 popular_recs_filtered

00:01:01.484 --> 00:01:06.329
可以从这里的正文看出

00:01:06.329 --> 00:01:08.159
它将接受这些参数

00:01:08.159 --> 00:01:12.424
包括 user_id、n_top 像之前一样

00:01:12.424 --> 00:01:16.534
ranked_movies 我在这里使用了它

00:01:16.534 --> 00:01:19.560
然后是 years 和 genres

00:01:19.560 --> 00:01:23.314
至少从这行代码可以看出

00:01:23.314 --> 00:01:27.034
它将 years 和 genres 当做列表

00:01:27.034 --> 00:01:32.439
然后使用这些列表 遍历列表中的值

00:01:32.439 --> 00:01:39.579
从 ranked_movies DataFrame 中仅提取属于这些值的值

00:01:39.579 --> 00:01:43.810
最简单的方法是查看 ranked_movies

00:01:43.810 --> 00:01:48.314
如果我们想提取特定的日期

00:01:48.314 --> 00:01:50.084
例如

00:01:50.084 --> 00:01:55.780
“请返回日期为 2015 年或 2016 年

00:01:55.780 --> 00:01:57.585
或 2017 年的已排名电影”

00:01:57.584 --> 00:02:00.469
可以在下面看到这些日期

00:02:00.469 --> 00:02:08.275
如果输入 2015

00:02:08.275 --> 00:02:10.289
Ok不可行

00:02:10.289 --> 00:02:14.259
如果设为列表呢？

00:02:16.610 --> 00:02:24.760
好的Yeah如果传入存储日期的列表

00:02:24.759 --> 00:02:26.299
则仅返回这些日期的电影

00:02:26.300 --> 00:02:29.945
试试 2016

00:02:29.944 --> 00:02:34.549
Great如果传入包含多个日期的列表

00:02:34.550 --> 00:02:40.405
则返回日期在此范围内的已排名电影

00:02:40.405 --> 00:02:43.685
将这行代码添加到这里

00:02:43.685 --> 00:02:47.930
假设我们想要“返回日期在此范围内的已排名电影”

00:02:47.930 --> 00:02:52.819
我们希望这个是传入的 years 列表

00:02:52.819 --> 00:02:58.810
这就是新的 ranked_movies DataFrame

00:02:58.810 --> 00:03:01.295
与此同时

00:03:01.294 --> 00:03:05.299
我们还可以查看 genres

00:03:05.300 --> 00:03:10.990
这个有点难

00:03:10.990 --> 00:03:14.620
因为可能属于多种类型

00:03:14.620 --> 00:03:17.384
例如短片 喜剧 剧情

00:03:17.384 --> 00:03:19.340
这里有三种类型

00:03:19.340 --> 00:03:21.534
这里有两种

00:03:21.534 --> 00:03:24.590
这个电影只属于一种类型

00:03:24.590 --> 00:03:27.745
使问题变得更难

00:03:27.745 --> 00:03:31.659
我的解决方法是

00:03:31.819 --> 00:03:37.459
我们来看看 ranked_movies 如果提取 history 列

00:03:37.460 --> 00:03:43.715
如果 movie_id 属于该类型 则这里是 1 否则是 0

00:03:43.715 --> 00:03:45.210
但是如果传入...

00:03:45.210 --> 00:03:52.314
假设我们想要获取历史科幻片 提取这两种类型

00:03:52.314 --> 00:03:54.814
则会获得这两列

00:03:54.814 --> 00:03:57.379
如果这是一个 OR 语句

00:03:57.379 --> 00:04:03.289
如果我希望类型是历史片或科幻片或其他类型

00:04:03.289 --> 00:04:06.370
我希望返回这部电影

00:04:06.370 --> 00:04:08.405
并返回这部电影

00:04:08.405 --> 00:04:10.175
但是不想返回这些电影

00:04:10.175 --> 00:04:11.415
依然想要返回这个

00:04:11.414 --> 00:04:13.275
不能只查看这列

00:04:13.275 --> 00:04:16.959
我们需要求和

00:04:16.959 --> 00:04:24.774
如果和大于 0

00:04:24.774 --> 00:04:28.264
则表明这部电影至少属于一种类型

00:04:28.264 --> 00:04:29.829
和也可能是 3

00:04:29.829 --> 00:04:32.194
表示属于多种类型

00:04:32.194 --> 00:04:35.969
方法是采用这个 OR 语句

00:04:35.970 --> 00:04:41.980
如果是历史片或科幻片或其他类型

00:04:41.980 --> 00:04:45.035
是其中的任何一种类型 则返回电影

00:04:45.035 --> 00:04:47.975
也就是这部分代码的作用

00:04:47.975 --> 00:04:51.240
我将使用这部分代码

00:04:52.790 --> 00:04:56.875
如果这个大于 0

00:04:56.875 --> 00:04:59.824
那么表明

00:04:59.824 --> 00:05:05.264
这行的已排名电影至少具有属于其中一种类型的电影

00:05:05.264 --> 00:05:09.868
将这个称为 num_genre_match

00:05:09.869 --> 00:05:16.600
我们想要返回的 ranked_movies

00:05:16.600 --> 00:05:25.075
等于包含行大于 0 的 ranked_movies

00:05:25.074 --> 00:05:28.495
如果这个大于 0 则返回这些电影

00:05:28.495 --> 00:05:31.625
我们可以返回所有这些列

00:05:31.625 --> 00:05:38.620
这个 ranked_movies...这里不再是这两种类型

00:05:38.620 --> 00:05:42.840
而是整个 genres 列表

00:05:42.839 --> 00:05:44.894
我们来看看有多少类型

00:05:44.894 --> 00:05:49.729
这个和将告诉我们任何特定行出现了多少种类型

00:05:49.730 --> 00:05:55.254
如果该行有多种类型

00:05:55.254 --> 00:05:57.139
则返回该行

00:05:57.139 --> 00:06:02.235
与上面的这个 top_movies 函数类似

00:06:02.235 --> 00:06:04.939
我们可以直接使用它

00:06:04.939 --> 00:06:10.920
这些行是为了创建过滤器

00:06:10.920 --> 00:06:12.504
这是一个过滤器

00:06:12.504 --> 00:06:14.420
这是另一个过滤器

00:06:14.420 --> 00:06:17.949
传入 years 和 genre 然后创建 top_movies

00:06:17.949 --> 00:06:19.050
最后

00:06:19.050 --> 00:06:23.600
返回 top_movies

